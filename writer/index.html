<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Craft GUI</title>
    <link rel="icon" href="writer.webp">
	<meta name="darkreader-lock">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            display: flex;
        }
        #left-panel {
            width: 200px;
            background-color: #e5e7eb;
            padding: 16px;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 2000;
            position: relative; /* Added for positioning child button */
            transition: margin-left 0.3s ease-in-out; /* Added for smooth slide */
        }
        .dark #left-panel {
            background-color: #374151;
            color: #d1d5db;
        }
        #left-panel.minimized { /* Style for minimized panel */
            margin-left: -200px; /* Moves panel off-screen to the left */
        }

        .panel-node-type {
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: #fff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: grab;
            text-align: center;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .dark .panel-node-type {
            background-color: #4b5563;
            border-color: #6b7280;
        }

        #main-content-area {
            flex-grow: 1;
            position: relative;
            height: 100vh;
            overflow: hidden;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top:0; left:0;
            overflow: hidden;
            background-color: #f3f4f6;
        }
        .dark #graph-canvas {
            background-color: #1f2937;
        }

        #world-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100000%; /* Allow for "infinite" panning */
            height: 100000%; /* Allow for "infinite" panning */
            transform-origin: 0 0;
        }


        .node {
            position: absolute;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: grab;
            user-select: none;
            min-width: 200px;
            transition: box-shadow 0.2s ease-in-out, border-color 0.3s ease;
            background-color: #fff;
            border: 1px solid #d1d5db;

        }
        .node-scene {
            min-height: 80px;
        }
        .node.selected {
            box-shadow: 0 0 0 3px #3b82f6, 0 6px 12px rgba(0,0,0,0.2);
            z-index: 1000 !important; /* Ensure selected node is on top */
        }
        .node-error-highlight {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 3px #ef4444, 0 6px 12px rgba(239,68,68,0.4) !important;
        }

        .node-title {
            padding: 8px 12px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            font-weight: 600;
            background-color: #e5e7eb;
            color: #374151;
        }
        .node-content {
            padding: 12px;
            font-size: 0.875rem;
            position: relative; /* For port label positioning */
        }
        .node-port {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            background-color: #9ca3af;
            cursor: crosshair;
            transition: background-color 0.2s;
            z-index: 1; /* Above node content for easier clicking */
            margin-top: 24px; /* Default vertical alignment with first potential element */
        }
        .node-port:hover {
            background-color: #3b82f6;
        }
        .node-port.input { left: -6px; }
        .node-port.output { right: -6px; }
        .node-port.output-decision { right: -6px; } /* Specific for directive options */

        .port-label {
            position: absolute;
            font-size: 0.65rem;
            color: #4b5563;
            pointer-events: none; /* So they don't interfere with port clicks */
            white-space: nowrap;
            line-height: 12px; /* Aligns with port height */
            margin-top: -9px; /* Adjust to center vertically with the port's default top */
        }
        .dark .port-label {
            color: #9ca3af;
        }
        .port-label.input { left: 10px; transform: translateY(-50%); }
        .port-label.output { right: 10px; transform: translateY(-50%); text-align: right; }

        .dark .node {
            background-color: #374151;
            color: #d1d5db;
            border-color: #4b5563;
        }
        .dark .node-title {
            background-color: #4b5563;
            color: #f3f4f6;
        }
        .dark .node-port {
            background-color: #6b7280;
        }
        .dark .node-port:hover {
            background-color: #60a5fa;
        }
        .dark .modal-content, .dark .settings-panel, .dark #read-story-modal-content, .dark #confirm-new-graph-modal-content {
            background-color: #374151;
            color: #d1d5db;
        }
         .dark #read-story-modal-content hr {
            border-color: #4b5563;
        }
        .dark input, .dark textarea, .dark select {
            background-color: #4b5563;
            color: #d1d5db;
            border-color: #6b7280;
        }
        .dark input[type="checkbox"] {
            accent-color: #4f46e5; /* Or your preferred accent */
        }
        .dark button:not(.panel-node-type) { /* General button styling for dark mode */
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        .dark button:not(.panel-node-type):hover {
            background-color: #4338ca; /* indigo-700 */
        }
        .dark .button-secondary {
             background-color: #4b5563; /* gray-600 */
        }
        .dark .button-secondary:hover {
             background-color: #6b7280; /* gray-500 */
        }
         .dark .button-danger {
            background-color: #dc2626; /* Red-600 */
        }
        .dark .button-danger:hover {
            background-color: #b91c1c; /* Red-700 */
        }

        /* Sound Node Specific UI - START */
        .sound-node-ui {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .selected-sound-display {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #fff;
        }
        .dark .selected-sound-display {
            background-color: #4b5563;
            border-color: #6b7280;
        }
        .selected-sound-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }
        .dropdown-arrow-symbol {
            margin-left: 8px;
            font-size: 0.8em;
            transition: transform 0.2s ease-in-out;
        }
        .selected-sound-display.open .dropdown-arrow-symbol {
            transform: rotate(180deg);
        }
        .sound-dropdown-list {
            border: 1px solid #d1d5db;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 220px;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #fff;
            position: relative;
            z-index: 10;
            margin-top: -1px;
            display: flex;
            flex-direction: column;
        }
        .dark .sound-dropdown-list {
            background-color: #374151;
            border-color: #6b7280;
        }
        .sound-dropdown-list.hidden {
            display: none;
        }
        .sound-list-scroll-container {
            flex-grow: 1;
            overflow-y: auto;
            max-height: 180px;
        }
        .sound-category .category-header {
            padding: 6px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-weight: 600;
            background-color: #f3f4f6;
            border-bottom: 1px solid #e5e7eb;
            border-top: 1px solid #e5e7eb;
        }
        .sound-category:first-child .category-header {
            border-top: none;
        }
        .dark .sound-category .category-header {
            background-color: #4b5563;
            border-color: #6b7280;
        }
        .category-arrow-symbol {
            margin-right: 6px;
            transition: transform 0.2s;
            display: inline-block;
            width: 10px;
        }
        .category-header.expanded .category-arrow-symbol {
            transform: rotate(90deg);
        }
        .category-sounds {
            padding-left: 10px;
        }
        .category-sounds.hidden {
            display: none;
        }
        .sound-item {
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.825rem;
        }
        .sound-item:hover, .sound-item.selected {
            background-color: #e5e7eb;
        }
        .dark .sound-item:hover, .dark .sound-item.selected {
            background-color: #6b7280;
        }
        .sound-search-input-node {
            width: calc(100% - 16px);
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
            box-sizing: border-box;
            margin: 8px;
            flex-shrink: 0;
        }
        .dark .sound-search-input-node {
            background-color: #4b5563;
            border-color: #6b7280;
            color: #d1d5db;
        }
        .node-sound-play-btn {
            background-color: #60a5fa;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-top: 8px;
        }
        .node-sound-play-btn:hover {
            background-color: #3b82f6;
        }
        .dark .node-sound-play-btn {
            background-color: #3b82f6;
        }
        .dark .node-sound-play-btn:hover {
            background-color: #2563eb;
        }
        .node-sound-play-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        /* Sound Node Specific UI - END */


        #wires-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        .wire {
            stroke: #6b7280;
            stroke-width: 2.5;
            fill: none;
            vector-effect: non-scaling-stroke;
        }
        .dark .wire {
            stroke: #9ca3af;
        }
        .temp-wire {
            stroke: #3b82f6;
            stroke-width: 2.5;
            fill: none;
            stroke-dasharray: 5,5;
            vector-effect: non-scaling-stroke;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            min-width: 300px;
            max-width: 500px;
            text-align: center;
        }

        #confirm-new-graph-modal-content {
             background-color: white;
             padding: 24px;
             border-radius: 8px;
             box-shadow: 0 10px 25px rgba(0,0,0,0.1);
             min-width: 350px;
             text-align: left;
        }
        #confirm-new-graph-modal-content h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
        }
        #confirm-new-graph-modal-content p {
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #4b5563;
        }
        .dark #confirm-new-graph-modal-content p {
            color: #d1d5db;
        }
        #confirm-new-graph-modal-content .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        #confirm-new-graph-modal-content .checkbox-container input[type="checkbox"] {
            margin-right: 0.5rem;
            height: 1rem;
            width: 1rem;
        }
        #confirm-new-graph-modal-content .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }


        #read-story-modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto; /* Ensures scrolling if content overflows */
            text-align: left;
        }
        #read-story-modal-content h3 { margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600;}
        #read-story-modal-content hr { margin: 1rem 0; border-top: 1px solid #e5e7eb; }
        #read-story-modal-content p { margin-bottom: 0.5rem; white-space: pre-wrap; }
        #read-story-modal-content strong { font-weight: 600; }


        .settings-panel {
            position: fixed;
            top: 20px;
            right: -400px;
            width: 350px;
            height: calc(100vh - 40px);
            background-color: white;
            padding: 20px;
            border-radius: 8px 0 0 8px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            z-index: 9000;
            transition: right 0.3s ease-in-out;
            overflow-y: auto;
        }
        .settings-panel.open {
            right: 0;
        }
        .settings-panel label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .settings-panel .toggle-label-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .settings-panel .toggle-label {
            margin-left: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
        }
        .settings-panel input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            margin-bottom: 0.75rem;
        }
        .dark .settings-panel input[type="text"] {
            background-color: #4b5563;
            border-color: #6b7280;
            color: #e5e7eb;
        }


        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 10001;
            min-width: 200px;
        }
        .dark .context-menu {
            background-color: #374151;
            border-color: #4b5563;
            color: #e5e7eb;
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .context-menu-item:hover {
            background-color: #f3f4f6;
        }
        .dark .context-menu-item:hover {
            background-color: #4b5563;
            color: #f9fafb;
        }
        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .expanded .expandable-content {
            max-height: 500px;
        }
        .node-content label {
            display: block;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .node-content input[type="text"],
        .node-content input[type="number"], /* Added for number inputs like Delay */
        .node-content textarea,
        .node-content select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
            margin-bottom: 8px;
            box-sizing: border-box;
        }
        .node-content button {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-top: 4px;
        }

        .toggle-switch:checked ~ .dot {
            transform: translateX(100%);
            background-color: #4f46e5;
        }
        .toggle-switch:checked ~ .block {
            background-color: #6d28d9;
        }
        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 10002;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .dark .toast-notification {
            background-color: #4b5563;
            color: #e5e7eb;
        }
    </style>
</head>
<body class="overflow-hidden">
    <div id="left-panel">
        <button id="minimize-panel-btn" title="Minimize Panel" class="absolute top-2 right-2 p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 z-[2001]">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
            </svg>
        </button>
        <h3 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-200">Nodes</h3>
        </div>

    <button id="restore-panel-btn" title="Restore Panel" class="hidden fixed top-2 left-2 p-1 bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-md shadow-md z-[2002]">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
        </svg>
    </button>

    <div id="main-content-area">
        <div id="graph-canvas">
            <div id="world-container">
                <svg id="wires-svg"></svg> </div>
        </div>
    </div>

    <div id="startup-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-semibold mb-6">Story Craft GUI</h2>
            <button id="new-story-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
                Begin a New Story Graph
            </button>
            <button id="open-saved-story-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg w-full hidden">
                Open Saved Graph
            </button>
        </div>
    </div>

    <div id="confirm-new-graph-modal" class="modal hidden">
        <div id="confirm-new-graph-modal-content">
            <h2>Start New Graph?</h2>
            <p>Starting a new graph will clear your current workspace. Any unsaved changes in the editor will be lost. If you have a graph saved in cookies, this action will not delete it unless you explicitly choose to save this new empty graph over it later.</p>
            <div class="checkbox-container">
                <input type="checkbox" id="backup-current-graph-checkbox" checked class="form-checkbox h-5 w-5 text-indigo-600 transition duration-150 ease-in-out">
                <label for="backup-current-graph-checkbox" class="ml-2 text-sm text-gray-700 dark:text-gray-300">Backup saved graph (from cookies) to JSON file</label>
            </div>
            <div class="button-group">
                <button id="confirm-new-graph-cancel-btn" class="button-secondary bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-lg">
                    Cancel
                </button>
                <button id="confirm-new-graph-confirm-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg">
                    Confirm
                </button>
            </div>
        </div>
    </div>


    <div id="settings-panel" class="settings-panel">
        <h3 class="text-xl font-semibold mb-6">Settings</h3>

        <div class="mb-4">
            <label for="story-title-input">Story Name:</label>
            <input type="text" id="story-title-input" placeholder="Enter story name">
        </div>
        <div class="mb-4">
            <label for="story-author-input">Author:</label>
            <input type="text" id="story-author-input" placeholder="Enter author name">
        </div>
        <div class="mb-6">
            <label for="story-tags-input">Tags (comma-separated):</label>
            <input type="text" id="story-tags-input" placeholder="e.g., romance, drama">
        </div>

        <div class="mb-4 border-t border-gray-300 dark:border-gray-600 pt-4 toggle-label-container">
            <label for="dark-mode-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="dark-mode-toggle" class="sr-only toggle-switch">
                    <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                </div>
                <div class="toggle-label">Dark Mode</div>
            </label>
        </div>
        <div class="mb-4 toggle-label-container">
             <label for="always-download-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="always-download-toggle" class="sr-only toggle-switch">
                    <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                </div>
                <span class="toggle-label">Always Download on Ctrl+S</span>
            </label>
        </div>


        <button id="export-graph-json-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
            Export Graph (Editor Format)
        </button>
        <button id="export-story-narrative-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
            Export Story (Narrative Format)
        </button>

        <div class="mb-3">
            <label for="import-json-file" class="block text-sm font-medium mb-1">Import Graph (Editor Format):</label>
            <input type="file" id="import-json-file" accept=".json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100">
        </div>

        <button id="clear-saved-graph-btn" class="button-danger bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg w-full mt-4">
            Clear Saved Graph Data (from Cookies)
        </button>

        <p class="text-xs text-gray-500 dark:text-gray-400 mt-6">Press Ctrl+S to save the current graph to cookies (or download if preferred/too large).</p>
    </div>

    <div id="context-menu" class="context-menu hidden">
        </div>

    <div id="read-story-modal" class="modal hidden">
        <div id="read-story-modal-content">
            <h3>Story Path</h3>
            <div id="story-path-display"></div>
            <button id="close-read-story-modal-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg mt-6">Close</button>
        </div>
    </div>


    <script>
        // --- Global State & Configuration ---
        let nodes = [];
        let wires = [];
        let selectedNodeId = null;
        let selectedElement = null;
        let offset = { x: 0, y: 0 };
        let currentZoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanPosition = { x: 0, y: 0 };
        let lastMouseScreenX = 0;
        let lastMouseScreenY = 0;

        // Story metadata (part of graph data)
        let storyTitle = "My Awesome Story";
        let storyAuthor = "";
        let storyTags = "";

        // User preferences (stored separately)
        let darkModeEnabled = false;
        let alwaysDownloadOnSave = false;


        let isWiring = false;
        let tempWire = null;
        let startPort = null;
        // Available colors for wires
        let wireColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FED766', '#2AB7CA', '#F07167', '#0081A7', '#00AFB9', '#FEDC97'];
        let highestZIndex = 1;

        // NEW: For revised wire coloring
        let wireCalculatedColors = new Map(); // Stores calculated color for each wire ID
        let globalColorPickerIndex = 0; // Used to cycle through wireColors for new paths


        // DOM Element References
        const graphCanvas = document.getElementById('graph-canvas');
        const worldContainer = document.getElementById('world-container');
        const wiresSvg = document.getElementById('wires-svg');
        const startupModal = document.getElementById('startup-modal');
        const newStoryBtn = document.getElementById('new-story-btn');
        const openSavedStoryBtn = document.getElementById('open-saved-story-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const alwaysDownloadToggle = document.getElementById('always-download-toggle');
        const exportGraphJsonBtn = document.getElementById('export-graph-json-btn');
        const exportStoryNarrativeBtn = document.getElementById('export-story-narrative-btn');
        const importJsonFile = document.getElementById('import-json-file');
        const contextMenu = document.getElementById('context-menu');
        const leftPanel = document.getElementById('left-panel');
        const mainContentArea = document.getElementById('main-content-area');
        const readStoryModal = document.getElementById('read-story-modal');
        const storyPathDisplay = document.getElementById('story-path-display');
        const closeReadStoryModalBtn = document.getElementById('close-read-story-modal-btn');
        const storyTitleInput = document.getElementById('story-title-input');
        const storyAuthorInput = document.getElementById('story-author-input');
        const storyTagsInput = document.getElementById('story-tags-input');
        const clearSavedGraphBtn = document.getElementById('clear-saved-graph-btn');
        const confirmNewGraphModal = document.getElementById('confirm-new-graph-modal');
        const confirmNewGraphConfirmBtn = document.getElementById('confirm-new-graph-confirm-btn');
        const confirmNewGraphCancelBtn = document.getElementById('confirm-new-graph-cancel-btn');
        const backupCurrentGraphCheckbox = document.getElementById('backup-current-graph-checkbox');
        const minimizePanelBtn = document.getElementById('minimize-panel-btn');
        const restorePanelBtn = document.getElementById('restore-panel-btn');


        // Constants
        const NODE_TYPES = ['Scene', 'Character', 'Dialogue', 'Interact', 'Directive', 'Weather', 'Time', 'Sound', 'Delay', 'Terminate'];
        const PORT_BASE_TOP_OFFSET = 28; // Vertical offset for the first port from the node content top
        const PORT_SPACING = 25; // Vertical spacing between multiple ports
        const COOKIE_SLICE_MAX_LENGTH = 3900; // Max length for a single cookie slice
        const MAX_COOKIE_SLICES = 20; // Max number of cookie slices for graph data
        const PREF_DARK_MODE = 'storyCraftPref_darkMode';
        const PREF_ALWAYS_DOWNLOAD = 'storyCraftPref_alwaysDownload';
        const GRAPH_DATA_COOKIE_PREFIX = 'storyGraphData_';
        const GRAPH_DATA_SLICES_COOKIE = 'storyGraphData_slices';
        const AUDIO_BASE_PATH = '../assets/audio/'; // Path used by the editor for previews

        let PROCESSED_SOUND_LIST = []; // Will hold processed sound file data


        // --- Utility Functions ---
        function generateId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        function getGraphCoordinates(screenX, screenY) {
            const graphCanvasRect = graphCanvas.getBoundingClientRect();
            return {
                x: (screenX - graphCanvasRect.left - panX) / currentZoom,
                y: (screenY - graphCanvasRect.top - panY) / currentZoom
            };
        }

        function updateWorldTransform() {
            worldContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
        }

        function showToast(message) {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) existingToast.remove();
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.classList.add('toast-notification');
            if(darkModeEnabled) toast.classList.add('dark');
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function generateCharacterReplaceKey(name) {
            if (!name || typeof name !== 'string' || name.trim() === "") return "_UNDEFINED_";
            let hexString = "";
            for (let i = 0; i < name.length; i++) {
                hexString += name.charCodeAt(i).toString(16);
            }
            return `_${hexString}_`;
        }

        function parseTimeToMinutes(timeStr) {
            if (!timeStr || typeof timeStr !== 'string') return null;
            const timeRegex = /^(\d{1,2}):(\d{2})\s*(AM|PM)$/i;
            const match = timeStr.match(timeRegex);
            if (!match) return null;
            let hours = parseInt(match[1], 10);
            const minutes = parseInt(match[2], 10);
            const ampm = match[3].toUpperCase();
            if (hours < 1 || hours > 12 || minutes < 0 || minutes > 59) return null;
            if (ampm === 'PM' && hours !== 12) hours += 12;
            else if (ampm === 'AM' && hours === 12) hours = 0;
            return hours * 60 + minutes;
        }

        function processAudioFiles(rawFilenamesFromPHP) {
            if (!Array.isArray(rawFilenamesFromPHP)) {
                console.error("processAudioFiles expects an array, received:", rawFilenamesFromPHP);
                return [];
            }
            return rawFilenamesFromPHP.map(rawFilename => {
                const parts = rawFilename.split('_');
                let category = "General";
                let nameParts = [...parts];
                if (parts.length > 1) {
                    category = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
                    nameParts.shift();
                }
                const displayName = nameParts.join(' ').replace(/_/g, ' ').split(' ')
                                       .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                       .join(' ');
                return {
                    category: category,
                    displayName: displayName || "Unnamed Sound",
                    filePath: AUDIO_BASE_PATH + rawFilename + ".mp3"
                };
            }).sort((a, b) => {
                if (a.category < b.category) return -1;
                if (a.category > b.category) return 1;
                if (a.displayName < b.displayName) return -1;
                if (a.displayName > b.displayName) return 1;
                return 0;
            });
        }


        // --- Preference Cookie Management ---
        function savePreference(prefName, value) {
            setCookie(prefName, JSON.stringify(value), 365);
        }

        function getPreference(prefName, defaultValue) {
            const cookieValue = getCookie(prefName);
            try {
                if (cookieValue !== null) return JSON.parse(cookieValue);
            } catch (e) {
                console.error(`Error parsing preference ${prefName}:`, e);
                return defaultValue;
            }
            return defaultValue;
        }

        function panToNode(nodeId) {
            const node = findNodeById(nodeId);
            const nodeEl = document.getElementById(nodeId);
            if (!node || !nodeEl) return;
            const graphCanvasRect = graphCanvas.getBoundingClientRect();
            const nodeWidth = nodeEl.offsetWidth;
            const nodeHeight = nodeEl.offsetHeight;

            panX = graphCanvasRect.width / 2 - (node.x + nodeWidth / 2) * currentZoom;
            panY = graphCanvasRect.height / 2 - (node.y + nodeHeight / 2) * currentZoom;
            updateWorldTransform();
            redrawWires();
        }

        // --- Node Management ---
        function createNodeElement(node) {
            const nodeEl = document.createElement('div');
            nodeEl.id = node.id;
            nodeEl.classList.add('node', `node-${node.type.toLowerCase()}`, 'border');
            if (node.type === 'Scene') nodeEl.classList.add('node-scene');
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            node.zIndex = node.zIndex || highestZIndex++;
            nodeEl.style.zIndex = node.zIndex;

            const titleEl = document.createElement('div');
            titleEl.classList.add('node-title');
            titleEl.textContent = node.title || node.type;
            nodeEl.appendChild(titleEl);

            const contentEl = document.createElement('div');
            contentEl.classList.add('node-content');
            nodeEl.appendChild(contentEl);
            renderNodeSpecificContent(node, contentEl, nodeEl);


            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('node-port') || e.target.closest('input, textarea, select, button, .selected-sound-display, .sound-dropdown-list')) return;
                e.preventDefault();
                e.stopPropagation();
                selectNode(node.id);
                selectedElement = nodeEl;
                const graphCanvasRect = graphCanvas.getBoundingClientRect();
                const worldMouseX = (e.clientX - graphCanvasRect.left - panX) / currentZoom;
                const worldMouseY = (e.clientY - graphCanvasRect.top - panY) / currentZoom;
                offset.x = worldMouseX - node.x;
                offset.y = worldMouseY - node.y;
                nodeEl.style.cursor = 'grabbing';
            });
            worldContainer.appendChild(nodeEl);
            return nodeEl;
        }

        function addPortLabel(portEl, labelText, type) {
            const labelEl = document.createElement('div');
            const typeClasses = type.split(' ').filter(Boolean);
            labelEl.classList.add('port-label', ...typeClasses);
            labelEl.textContent = labelText;
            labelEl.style.top = portEl.style.top;
            const nodeContent = portEl.closest('.node')?.querySelector('.node-content');
            if (nodeContent) nodeContent.appendChild(labelEl);
            else console.warn("Could not find node-content for port label:", portEl.dataset.nodeId);
        }


        const POSE_OPTIONS = ["default", "standing", "sitting", "walking", "running", "happy", "sad", "angry", "surprised", "thinking", "custom"];
        const EXPRESSION_OPTIONS = ["default", "neutral", "smiling", "frowning", "crying", "blushing", "winking", "scared", "custom"];
        const OVERLAY_OPTIONS = ["none", "sweat", "tears", "blush_heavy", "glasses", "hat", "custom"];
        const WEATHER_CONDITION_OPTIONS = ["Clear", "Sunny", "Cloudy", "Partly Cloudy", "Overcast", "Rainy", "Light Rain", "Heavy Rain", "Stormy", "Thunderstorm", "Snowy", "Foggy", "Misty", "Windy"];

        function renderNodeSpecificContent(node, contentEl, nodeEl) {
            contentEl.innerHTML = ''; // Clear previous content

            const createLabel = (text) => { const l = document.createElement('label'); l.textContent = text; return l; };

            const createInput = (type, value, placeholder, onChange, isReadOnly = false, attributes = {}) => {
                const input = document.createElement(type === 'textarea' ? 'textarea' : 'input');
                if (type !== 'textarea') input.type = type;
                input.value = value || '';
                if (placeholder) input.placeholder = placeholder;
                if (isReadOnly) input.readOnly = true;
                else input.addEventListener('input', (e) => {
                    let val = e.target.value;
                    if (type === 'number') val = parseFloat(val);
                    onChange(val);
                    attemptSaveGraphToCookies();
                });
                if (type === 'textarea') input.rows = 3;
                for (const attr in attributes) {
                    input.setAttribute(attr, attributes[attr]);
                }
                return input;
            };

            const createSelect = (options, selectedValue, onChange, addEmptyOption = false, isSoundSelect = false) => {
                const select = document.createElement('select');
                if (addEmptyOption) {
                    const eo = document.createElement('option');
                    eo.setAttribute('disabled', 'disabled');
                    eo.setAttribute('hidden', 'hidden');
                    eo.value = "";
                    eo.textContent = isSoundSelect ? "Select Sound..." : `Select...`;
                    select.appendChild(eo);
                    if (!selectedValue) eo.selected = true;
                }

                if (isSoundSelect) {
                    const categories = {};
                    options.forEach(opt => {
                        if (!categories[opt.category]) categories[opt.category] = [];
                        categories[opt.category].push(opt);
                    });

                    Object.keys(categories).sort().forEach(categoryName => {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = categoryName;
                        categories[categoryName].sort((a,b) => a.displayName.localeCompare(b.displayName)).forEach(soundOpt => {
                            const oel = document.createElement('option');
                            oel.value = soundOpt.filePath;
                            oel.textContent = soundOpt.displayName;
                            if (soundOpt.filePath === selectedValue) oel.selected = true;
                            optgroup.appendChild(oel);
                        });
                        select.appendChild(optgroup);
                    });
                } else {
                    options.forEach(opt => {
                        const oel = document.createElement('option');
                        oel.value = typeof opt === 'string' ? opt : opt.value;
                        oel.textContent = typeof opt === 'string' ? opt : opt.text;
                        if ((typeof opt === 'string' ? opt : opt.value) === selectedValue) oel.selected = true;
                        select.appendChild(oel);
                    });
                }
                select.addEventListener('change', (e) => { onChange(e.target.value); attemptSaveGraphToCookies(); });
                return select;
            };

            // Remove existing ports before re-rendering
            nodeEl.querySelectorAll('.node-port').forEach(p => p.remove());
            contentEl.querySelectorAll('.port-label').forEach(l => l.remove());


            if (node.type === 'Scene') {
                const narrativeOutPort = createPort(node.id, 'output', 'narrative-out', 0);
                nodeEl.appendChild(narrativeOutPort);
                addPortLabel(narrativeOutPort, "Narrative Out", "output");
                updateSceneCharacterPorts(node, nodeEl);
            } else if (node.type === 'Character') {
                contentEl.appendChild(createLabel('Name:'));
                const nameInput = createInput('text', node.properties.name, 'Character Name', (val) => {
                    node.properties.name = val;
                    node.properties.replaceKey = generateCharacterReplaceKey(val);
                    const replaceKeyInputEl = contentEl.querySelector('input[placeholder="Auto-generated Key"]');
                    if (replaceKeyInputEl) replaceKeyInputEl.value = node.properties.replaceKey;
                    updateAllCharacterDependentNodes();
                });
                contentEl.appendChild(nameInput);
                contentEl.appendChild(createLabel('Replace Key:'));
                if (!node.properties.replaceKey || node.properties.replaceKey === '_NEW_CHAR') {
                     node.properties.replaceKey = generateCharacterReplaceKey(node.properties.name);
                }
                const replaceKeyInput = createInput('text', node.properties.replaceKey, 'Auto-generated Key', null, true);
                contentEl.appendChild(replaceKeyInput);
                const charOutputPort = createPort(node.id, 'output', 'char-out', 0);
                nodeEl.appendChild(charOutputPort);
            } else if (['Dialogue', 'Interact', 'Directive'].includes(node.type)) {
                const generalInputPortCommon = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortCommon);
                const characters = nodes.filter(n => n.type === 'Character').map(n => ({ value: n.id, text: n.properties.name || `Char (${n.id.substring(0,4)})` }));

                if (node.type === 'Dialogue') {
                    contentEl.appendChild(createLabel('Character:'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val, true));
                    contentEl.appendChild(createLabel('Dialogue Text:'));
                    contentEl.appendChild(createInput('textarea', node.properties.text, 'Character says...', val => node.properties.text = val));
                } else if (node.type === 'Interact') {
                    contentEl.appendChild(createLabel('Character (Prompter):'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val, true));
                    contentEl.appendChild(createLabel('Prompt Text (use \\ansX or \\monX):'));
                    contentEl.appendChild(createInput('textarea', node.properties.promptText, 'e.g., What is your \\ans10 name?', val => node.properties.promptText = val));
                    contentEl.appendChild(createLabel('Placeholder:'));
                    contentEl.appendChild(createInput('text', node.properties.placeholder, 'e.g., adjective', val => node.properties.placeholder = val));
                } else { // Directive
                    contentEl.appendChild(createLabel('Character (Actor):'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val, true));
                    contentEl.appendChild(createLabel('Prompt/Situation:'));
                    contentEl.appendChild(createInput('textarea', node.properties.promptText, 'Situation leading to choice', val => node.properties.promptText = val));
                }


                if (node.type === 'Dialogue' || node.type === 'Interact') {
                    const advancedToggle = document.createElement('button');
                    advancedToggle.textContent = contentEl.classList.contains('expanded') ? 'Advanced Options ▲' : 'Advanced Options ▼';
                    advancedToggle.classList.add('text-sm', 'text-blue-600', 'dark:text-blue-400', 'mt-2', 'w-full', 'text-left');
                    const advancedContent = document.createElement('div');
                    advancedContent.classList.add('expandable-content', 'mt-2', 'border-t', 'pt-2', 'dark:border-gray-600');
                    if (contentEl.classList.contains('expanded')) advancedContent.style.maxHeight = '500px';
                    advancedContent.appendChild(createLabel('Pose:'));
                    advancedContent.appendChild(createSelect(POSE_OPTIONS, node.properties.pose, val => node.properties.pose = val));
                    advancedContent.appendChild(createLabel('Expression:'));
                    advancedContent.appendChild(createSelect(EXPRESSION_OPTIONS, node.properties.expression, val => node.properties.expression = val));
                    advancedContent.appendChild(createLabel('Overlays:'));
                    advancedContent.appendChild(createSelect(OVERLAY_OPTIONS, node.properties.overlays, val => node.properties.overlays = val));
                    contentEl.appendChild(advancedToggle);
                    contentEl.appendChild(advancedContent);
                    advancedToggle.onclick = () => {
                        contentEl.classList.toggle('expanded');
                        advancedToggle.textContent = contentEl.classList.contains('expanded') ? 'Advanced Options ▲' : 'Advanced Options ▼';
                    };
                }

                if (node.type !== 'Directive') {
                    const generalOutputPortCommon = createPort(node.id, 'output', 'general-output', 0);
                    nodeEl.appendChild(generalOutputPortCommon);
                } else {
                    const decisionsContainer = document.createElement('div');
                    contentEl.appendChild(decisionsContainer);
                    const renderDecisions = () => {
                        decisionsContainer.innerHTML = '';
                        nodeEl.querySelectorAll('.node-port.output-decision').forEach(p => p.remove());
                        node.properties.options.forEach((opt, index) => {
                            const decisionDiv = document.createElement('div');
                            decisionDiv.classList.add('border', 'p-2', 'rounded', 'mb-2', 'relative', 'dark:border-gray-600');
                            decisionDiv.appendChild(createLabel(`Option ${index + 1} Summary:`));
                            const summaryInput = createInput('text', opt.summary, 'Summary', val => opt.summary = val);
                            decisionDiv.appendChild(summaryInput);
                            const removeBtn = document.createElement('button');
                            removeBtn.textContent = 'Remove';
                            removeBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'text-xs', 'absolute', 'top-1', 'right-1', 'p-1', 'rounded');
                            removeBtn.onclick = () => {
                                node.properties.options.splice(index, 1);
                                wires = wires.filter(w => !(w.fromNode === node.id && w.fromPort === `option-${opt.id}`));
                                renderDecisions();
                                updateAllWireColors(); // Update colors on structural change
                                redrawWires(); attemptSaveGraphToCookies();
                            };
                            decisionDiv.appendChild(removeBtn);
                            decisionsContainer.appendChild(decisionDiv);
                            const portId = `option-${opt.id}`;
                            const optionPort = createPort(node.id, 'output-decision', portId, 0);
                            requestAnimationFrame(() => { // Ensure elements are in DOM for offset calculations
                                if (summaryInput.offsetParent && decisionDiv.offsetParent) {
                                     optionPort.style.top = `${decisionDiv.offsetTop + summaryInput.offsetTop + (summaryInput.offsetHeight / 2) - (optionPort.offsetHeight / 2)}px`;
                                } else { // Fallback if not in DOM (e.g., during initial load of complex node)
                                    optionPort.style.top = `${PORT_BASE_TOP_OFFSET + index * (PORT_SPACING + (summaryInput.offsetHeight || 20) + 16)}px`;
                                }
                            });
                            nodeEl.appendChild(optionPort);
                        });
                    };
                    const addDecisionBtn = document.createElement('button');
                    addDecisionBtn.textContent = 'Add Decision';
                    addDecisionBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'w-full', 'mt-2', 'rounded');
                    addDecisionBtn.onclick = () => {
                        node.properties.options.push({ id: generateId(), summary: ''});
                        renderDecisions();
                        updateAllWireColors(); // Update colors on structural change
                        redrawWires();
                        attemptSaveGraphToCookies();
                    };
                    contentEl.appendChild(addDecisionBtn);
                    renderDecisions();
                }
            } else if (node.type === 'Weather' || node.type === 'Time') {
                const generalInputPortWT = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortWT);
                if (node.type === 'Weather') {
                    contentEl.appendChild(createLabel('Condition:'));
                    contentEl.appendChild(createSelect(WEATHER_CONDITION_OPTIONS, node.properties.condition, val => node.properties.condition = val));
                } else { // Time
                    contentEl.appendChild(createLabel('Time (HH:MM AM/PM):'));
                    contentEl.appendChild(createInput('text', node.properties.time, 'e.g., 08:00 AM', val => node.properties.time = val));
                }
                const generalOutputPortWT = createPort(node.id, 'output', 'general-output', 0);
                nodeEl.appendChild(generalOutputPortWT);
            } else if (node.type === 'Sound') {
                const generalInputPortSound = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortSound);

                const soundUiContainer = document.createElement('div');
                soundUiContainer.classList.add('sound-node-ui');

                const selectedSoundDisplay = document.createElement('div');
                selectedSoundDisplay.classList.add('selected-sound-display');
                const selectedSoundNameSpan = document.createElement('span');
                selectedSoundNameSpan.classList.add('selected-sound-name');
                selectedSoundNameSpan.textContent = node.properties.selectedSoundDisplayName || 'Select Sound...';
                const dropdownArrowSpan = document.createElement('span');
                dropdownArrowSpan.classList.add('dropdown-arrow-symbol');
                dropdownArrowSpan.innerHTML = '&#9660;'; // Down arrow

                selectedSoundDisplay.appendChild(selectedSoundNameSpan);
                selectedSoundDisplay.appendChild(dropdownArrowSpan);
                soundUiContainer.appendChild(selectedSoundDisplay);

                const soundDropdownList = document.createElement('div');
                soundDropdownList.classList.add('sound-dropdown-list', 'hidden');

                const soundSearchInput = createInput('text', node.properties.soundSearchTerm || '', 'Search sounds...', (val) => {
                    node.properties.soundSearchTerm = val;
                    populateCustomSoundList(soundDropdownList.querySelector('.sound-list-scroll-container'), selectedSoundNameSpan, dropdownArrowSpan, node, val);
                    if (val && soundDropdownList.classList.contains('hidden')) { // Open if searching and closed
                        soundDropdownList.classList.remove('hidden');
                        selectedSoundDisplay.classList.add('open');
                        dropdownArrowSpan.innerHTML = '&#9650;'; // Up arrow
                    }
                     attemptSaveGraphToCookies();
                });
                soundSearchInput.classList.add('sound-search-input-node');
                soundSearchInput.addEventListener('click', (e) => e.stopPropagation()); // Prevent dropdown close
                soundDropdownList.appendChild(soundSearchInput);

                const soundListScrollContainer = document.createElement('div');
                soundListScrollContainer.classList.add('sound-list-scroll-container');
                soundDropdownList.appendChild(soundListScrollContainer);

                soundUiContainer.appendChild(soundDropdownList);
                contentEl.appendChild(soundUiContainer);

                const playBtn = document.createElement('button');
                playBtn.classList.add('node-sound-play-btn');
                playBtn.innerHTML = `<svg viewBox="0 0 20 20"><path d="M12.92,1.3S12.29.62,11.66,0c-.5.05-1.05.39-1.05.39a10.2,10.2,0,0,0-1,1.83A10.14,10.14,0,0,0,9.24,4.91L8.1,6.42S8,6.54,8,6.68a.3.3,0,0,0,.35.28H8.7l3.81-2.15S13,4.51,13,4.21a.69.69,0,0,0-.13-.42Z"/><path d="M8.1,13.58,9.24,15.09a10.14,10.14,0,0,0,.39,2.69,10.2,10.2,0,0,0,1,1.83s.51.33,1.05.39c.63-.62.63-.62,0-1.3S11.15,16,11.15,16l-1.11-.93a15.5,15.5,0,0,1-.9-1.15Z"/><path d="M15.2,10.5a6.12,6.12,0,0,1-1.08,3.53,1,1,0,0,1-1.41.13,1,1,0,0,1-.13-1.41,4.11,4.11,0,0,0,.72-2.38,4.11,4.11,0,0,0-.72-2.38,1,1,0,0,1,.13-1.41,1,1,0,0,1,1.41.13A6.12,6.12,0,0,1,15.2,10.5Z"/><path d="M17.7,10.5a9.16,9.16,0,0,1-1.84,5.53,1,1,0,0,1-1.41-.05,1,1,0,0,1,.05-1.41A7.15,7.15,0,0,0,15.75,10.5a7.15,7.15,0,0,0-1.25-4.06,1,1,0,0,1-.05-1.41,1,1,0,0,1,1.41-.05A9.16,9.16,0,0,1,17.7,10.5Z"/><path d="M0,7.5v6H3.84L9,18.11V2.89L3.84,7.5Z"/></svg>`;
                playBtn.title = "Play Sound";
                playBtn.addEventListener('click', () => {
                    if (node.properties.selectedSoundPath) {
                        try {
                            const audio = new Audio(node.properties.selectedSoundPath);
                            audio.play().catch(e => {
                                console.error("Error playing audio:", e);
                                showToast("Could not play audio. Check console.");
                            });
                        } catch (e) {
                             console.error("Error creating audio element:", e);
                             showToast("Error with audio file path.");
                        }
                    } else {
                        showToast("No sound selected.");
                    }
                });
                contentEl.appendChild(playBtn);

                selectedSoundDisplay.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent click from bubbling to document
                    const isHidden = soundDropdownList.classList.toggle('hidden');
                    selectedSoundDisplay.classList.toggle('open', !isHidden);
                    dropdownArrowSpan.innerHTML = isHidden ? '&#9660;' : '&#9650;';
                    if (!isHidden) { // If opened
                        populateCustomSoundList(soundListScrollContainer, selectedSoundNameSpan, dropdownArrowSpan, node, soundSearchInput.value || '');
                        soundSearchInput.focus();
                    }
                });

                const generalOutputPortSound = createPort(node.id, 'output', 'general-output', 0);
                nodeEl.appendChild(generalOutputPortSound);
            } else if (node.type === 'Delay') {
                const generalInputPortDelay = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortDelay);

                contentEl.appendChild(createLabel('Delay (seconds):'));
                const delayInput = createInput('number', node.properties.delaySeconds, 'e.g., 1.5',
                    (val) => { node.properties.delaySeconds = Math.max(0.01, parseFloat(val) || 0); },
                    false,
                    { min: "0.00", step: "1.00" }
                );
                contentEl.appendChild(delayInput);

                const generalOutputPortDelay = createPort(node.id, 'output', 'general-output', 0);
                nodeEl.appendChild(generalOutputPortDelay);

            } else if (node.type === 'Terminate') {
                const generalInputPortTerminate = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortTerminate);
                const terminateText = document.createElement('p');
                terminateText.textContent = "Path Terminated";
                terminateText.classList.add('text-center', 'text-gray-500', 'dark:text-gray-400', 'py-2');
                contentEl.appendChild(terminateText);
            }
        }


        function populateCustomSoundList(scrollContainer, selectedNameElement, dropdownArrowElement, node, searchTerm) {
            scrollContainer.innerHTML = ''; // Clear previous items
            const lowerSearchTerm = (searchTerm || '').toLowerCase();
            const currentSelectedPath = node.properties.selectedSoundPath;
            const soundDropdownList = scrollContainer.parentElement; // The main dropdown list element

            if (!searchTerm) { // If no search term, show categorized list
                const categories = {};
                PROCESSED_SOUND_LIST.forEach(sound => {
                    if (!categories[sound.category]) {
                        categories[sound.category] = [];
                    }
                    categories[sound.category].push(sound);
                });

                Object.keys(categories).sort().forEach(categoryName => {
                    const categoryContainer = document.createElement('div');
                    categoryContainer.classList.add('sound-category');

                    const categoryHeader = document.createElement('div');
                    categoryHeader.classList.add('category-header');
                    const categoryArrow = document.createElement('span');
                    categoryArrow.classList.add('category-arrow-symbol');
                    categoryArrow.innerHTML = '&#9654;'; // Right arrow (collapsed)
                    const categoryNameSpan = document.createElement('span');
                    categoryNameSpan.textContent = categoryName;
                    categoryHeader.appendChild(categoryArrow);
                    categoryHeader.appendChild(categoryNameSpan);

                    const soundsContainer = document.createElement('div');
                    soundsContainer.classList.add('category-sounds', 'hidden'); // Initially hidden

                    categories[categoryName].sort((a, b) => a.displayName.localeCompare(b.displayName)).forEach(sound => {
                        const soundItem = document.createElement('div');
                        soundItem.classList.add('sound-item');
                        soundItem.textContent = sound.displayName;
                        soundItem.dataset.filePath = sound.filePath;
                        soundItem.dataset.displayName = sound.displayName;

                        if (sound.filePath === currentSelectedPath) {
                            soundItem.classList.add('selected');
                        }

                        soundItem.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent dropdown close
                            node.properties.selectedSoundPath = sound.filePath;
                            node.properties.selectedSoundDisplayName = sound.displayName;
                            selectedNameElement.textContent = sound.displayName;
                            if (soundDropdownList) soundDropdownList.classList.add('hidden');
                            dropdownArrowElement.parentElement.classList.remove('open'); // Update main dropdown arrow
                            dropdownArrowElement.innerHTML = '&#9660;';
                            attemptSaveGraphToCookies();
                            // Update selection visual
                            const currentlySelected = scrollContainer.querySelector('.sound-item.selected');
                            if (currentlySelected) currentlySelected.classList.remove('selected');
                            soundItem.classList.add('selected');
                        });
                        soundsContainer.appendChild(soundItem);
                    });

                    categoryHeader.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent main dropdown close
                        soundsContainer.classList.toggle('hidden');
                        categoryHeader.classList.toggle('expanded');
                        categoryArrow.innerHTML = soundsContainer.classList.contains('hidden') ? '&#9654;' : '&#9660;';
                    });

                    categoryContainer.appendChild(categoryHeader);
                    categoryContainer.appendChild(soundsContainer);
                    scrollContainer.appendChild(categoryContainer);
                });
                if (Object.keys(categories).length === 0 && PROCESSED_SOUND_LIST.length > 0) {
                     const noResultsItem = document.createElement('div');
                    noResultsItem.classList.add('sound-item');
                    noResultsItem.textContent = 'No sounds available in categories.';
                    scrollContainer.appendChild(noResultsItem);
                } else if (PROCESSED_SOUND_LIST.length === 0) {
                    const noResultsItem = document.createElement('div');
                    noResultsItem.classList.add('sound-item');
                    noResultsItem.textContent = 'No sounds loaded.';
                    scrollContainer.appendChild(noResultsItem);
                }


            } else { // If search term exists, show flat filtered list
                const filteredSounds = PROCESSED_SOUND_LIST.filter(sound =>
                    sound.displayName.toLowerCase().includes(lowerSearchTerm) ||
                    sound.category.toLowerCase().includes(lowerSearchTerm)
                ).sort((a, b) => a.displayName.localeCompare(b.displayName));

                filteredSounds.forEach(sound => {
                    const soundItem = document.createElement('div');
                    soundItem.classList.add('sound-item');
                    soundItem.textContent = sound.displayName;
                    soundItem.dataset.filePath = sound.filePath;
                    soundItem.dataset.displayName = sound.displayName;

                    if (sound.filePath === currentSelectedPath) {
                        soundItem.classList.add('selected');
                    }

                    soundItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        node.properties.selectedSoundPath = sound.filePath;
                        node.properties.selectedSoundDisplayName = sound.displayName;
                        selectedNameElement.textContent = sound.displayName;
                        if (soundDropdownList) soundDropdownList.classList.add('hidden');
                        dropdownArrowElement.parentElement.classList.remove('open');
                        dropdownArrowElement.innerHTML = '&#9660;';
                        attemptSaveGraphToCookies();
                        const currentlySelected = scrollContainer.querySelector('.sound-item.selected');
                        if (currentlySelected) currentlySelected.classList.remove('selected');
                        soundItem.classList.add('selected');
                    });
                    scrollContainer.appendChild(soundItem);
                });
                 if (filteredSounds.length === 0) {
                    const noResultsItem = document.createElement('div');
                    noResultsItem.classList.add('sound-item');
                    noResultsItem.textContent = 'No sounds match your search.';
                    noResultsItem.style.cursor = 'default';
                    noResultsItem.style.opacity = '0.7';
                    scrollContainer.appendChild(noResultsItem);
                }
            }
        }


        function updateSceneCharacterPorts(sceneNode, sceneNodeEl) {
            // Remove existing character input ports and labels
            sceneNodeEl.querySelectorAll('.node-port.input[data-port-type="character-input"]').forEach(p => p.remove());
            const contentEl = sceneNodeEl.querySelector('.node-content');
            if (contentEl) contentEl.querySelectorAll('.port-label.input.character-input-label').forEach(l => l.remove());

            // Count connected character wires
            const connectedCharWires = wires.filter(w => w.toNode === sceneNode.id && w.toPort.startsWith('char-in-'));
            const numChars = connectedCharWires.length;

            // Add ports: one for each connected char + one extra for a new connection
            for (let i = 0; i < numChars + 1; i++) {
                const portId = `char-in-${i}`;
                const port = createPort(sceneNode.id, 'input', portId, i, 'character-input');
                sceneNodeEl.appendChild(port);
                addPortLabel(port, `Char In ${i+1}`, "input character-input-label");
            }

            // Adjust scene node height if necessary (simple heuristic)
            const sceneContentEl = sceneNodeEl.querySelector('.node-content');
            if(sceneContentEl) sceneNodeEl.style.minHeight = `${60 + (numChars + 1) * PORT_SPACING + PORT_BASE_TOP_OFFSET}px`;

            updateAllCharacterDependentNodes(); // Refresh nodes that depend on character lists
        }

        function createPort(nodeId, type, portId, index, portType = 'general') {
            const port = document.createElement('div');
            port.classList.add('node-port', type);
            if (type === 'output-decision') port.classList.add('output'); // Ensure 'output' class for styling
            port.dataset.nodeId = nodeId; port.dataset.portId = portId; port.dataset.portType = portType;

            // Position port vertically, except for directive decision outputs which are positioned in renderNodeSpecificContent
            if (type !== 'output-decision' || portType === 'general') { // General output ports still use indexed positioning
                 port.style.top = `${PORT_BASE_TOP_OFFSET + index * PORT_SPACING}px`;
            }


            port.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent node dragging
                isWiring = true; startPort = port;
                tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tempWire.classList.add('temp-wire'); wiresSvg.appendChild(tempWire);
                document.body.style.cursor = 'crosshair';
            });


            port.addEventListener('mouseup', (e) => {
                if (isWiring && startPort && startPort !== port) { // Ensure wiring is active and not clicking the same port
                    const initialFromNodeId = startPort.dataset.nodeId;
                    const initialFromPortId = startPort.dataset.portId;
                    const initialToNodeId = port.dataset.nodeId;
                    const initialToPortId = port.dataset.portId;

                    const initialStartNode = findNodeById(initialFromNodeId);
                    const initialEndNode = findNodeById(initialToNodeId);

                    const initialStartPortType = startPort.classList.contains('input') ? 'input' : 'output';
                    const initialEndPortType = port.classList.contains('input') ? 'input' : 'output';

                    let sNodeId, sPortId, tNodeId, tPortId; // s = source (output), t = target (input)
                    let sNode, tNode;
                    let actualOutputPortEl, actualInputPortEl;

                    let canConnect = true;

                    if (!initialStartNode || !initialEndNode || initialFromNodeId === initialToNodeId) {
                        canConnect = false; // Invalid nodes or self-connection
                    } else if (initialStartPortType === initialEndPortType) {
                        canConnect = false; // Cannot connect input-to-input or output-to-output
                    } else if (initialStartPortType === 'output' && initialEndPortType === 'input') {
                        // Standard connection: output -> input
                        sNodeId = initialFromNodeId; sPortId = initialFromPortId;
                        tNodeId = initialToNodeId; tPortId = initialToPortId;
                        sNode = initialStartNode; tNode = initialEndNode;
                        actualOutputPortEl = startPort; actualInputPortEl = port;
                    } else if (initialStartPortType === 'input' && initialEndPortType === 'output') {
                        // Reversed connection: user dragged input -> output, treat as output -> input
                        sNodeId = initialToNodeId; sPortId = initialToPortId;     // Source is the 'output' port (where mouseup happened)
                        tNodeId = initialFromNodeId; tPortId = initialFromPortId; // Target is the 'input' port (where mousedown happened)
                        sNode = initialEndNode; tNode = initialStartNode;
                        actualOutputPortEl = port; actualInputPortEl = startPort;
                    } else {
                        canConnect = false; // Should be covered by previous checks
                    }

                    // Apply specific connection rules if basic conditions are met
                    if (canConnect) {
                        // Rule 1: Output from a Terminate node is not allowed (Terminate has no output ports).
                        if (sNode.type === 'Terminate') {
                            canConnect = false;
                        }
                        // Rule 2: Scene output ('narrative-out') specific connections.
                        // It must go to a 'general-input' port of a node that is NOT a Character node.
                        else if (sNode.type === 'Scene' && actualOutputPortEl.dataset.portId === 'narrative-out') {
                            if (actualInputPortEl.dataset.portId !== 'general-input' || tNode.type === 'Character') {
                                canConnect = false;
                            }
                        }
                        // Rule 3: Character output ('char-out') specific connections.
                        // It must go to a Scene's 'character-input' port.
                        else if (sNode.type === 'Character' && actualOutputPortEl.dataset.portId === 'char-out') {
                            if (!(tNode.type === 'Scene' && actualInputPortEl.dataset.portType === 'character-input')) {
                                canConnect = false;
                            }
                        }
                        // Rule 4: Scene input ('character-input') specific connections.
                        // If the target is a Scene's 'character-input' port, the source must be a Character's 'char-out'.
                        else if (tNode.type === 'Scene' && actualInputPortEl.dataset.portType === 'character-input') {
                            if (sNode.type !== 'Character' || actualOutputPortEl.dataset.portId !== 'char-out') {
                                canConnect = false;
                            }
                        }
                        // (Add other specific inter-node/port type rules here if needed in the future)
                    }


                    if (canConnect) {
                        // Remove existing wire if target is an input port (inputs only allow one connection).
                        // tNodeId and tPortId always refer to the actual input port at this stage.
                        wires = wires.filter(w => !(w.toNode === tNodeId && w.toPort === tPortId));

                        // Remove existing wire if source is a single-output port.
                        // sNodeId and sPortId always refer to the actual output port.
                        const isSingleOutputPortType =
                            (sNode.type === 'Scene' && sPortId === 'narrative-out') ||
                            (sNode.type === 'Character' && sPortId === 'char-out') ||
                            (['Dialogue', 'Interact', 'Weather', 'Time', 'Sound', 'Delay'].includes(sNode.type) && sPortId === 'general-output');

                        if (isSingleOutputPortType) {
                            wires = wires.filter(w => !(w.fromNode === sNodeId && w.fromPort === sPortId));
                        }

                        // Create the new wire with correctly oriented source and target.
                        const newWire = { id: generateId(), fromNode: sNodeId, fromPort: sPortId, toNode: tNodeId, toPort: tPortId };
                        wires.push(newWire);
                        updateAllWireColors(); // Recalculate all wire colors
                        redrawWires(); attemptSaveGraphToCookies();

                        // If connecting a Character to a Scene, update the Scene's character input ports.
                        // tNode is the Scene, sNode is the Character.
                        if (tNode.type === 'Scene' && sNode.type === 'Character') {
                            updateSceneCharacterPorts(tNode, document.getElementById(tNode.id));
                        }
                    }
                }
                stopWiring(); // Always stop wiring on mouseup, regardless of connection success
            });


            port.addEventListener('contextmenu', (e) => {
                e.preventDefault(); e.stopPropagation();
                const pNodeId = port.dataset.nodeId, pPortId = port.dataset.portId;
                const initialWireCount = wires.length;
                // Remove all wires connected to this port
                wires = wires.filter(w => !((w.fromNode === pNodeId && w.fromPort === pPortId) || (w.toNode === pNodeId && w.toPort === pPortId)));
                if (wires.length < initialWireCount) { // If wires were actually removed
                    const sceneNode = findNodeById(pNodeId);
                    if (sceneNode && sceneNode.type === 'Scene' && port.dataset.portType === 'character-input') {
                        updateSceneCharacterPorts(sceneNode, document.getElementById(pNodeId)); // Update Scene if a char input was affected
                    }
                    updateAllWireColors(); // Recalculate all wire colors
                    redrawWires(); attemptSaveGraphToCookies();
                }
            });
            return port;
        }

        function addNodeToGraph(type, x, y, properties = {}) {
            // Default properties for each node type
            const baseProps = {
                Scene: { title: 'Scene' }, Character: { title: 'Character', name: 'New Character', replaceKey: generateCharacterReplaceKey('New Character') },
                Dialogue: { title: 'Dialogue', characterId: null, text: '', pose: POSE_OPTIONS[0], expression: EXPRESSION_OPTIONS[0], overlays: OVERLAY_OPTIONS[0] },
                Interact: { title: 'Interact', characterId: null, promptText: '', placeholder: '', pose: POSE_OPTIONS[0], expression: EXPRESSION_OPTIONS[0], overlays: OVERLAY_OPTIONS[0] },
                Directive: { title: 'Directive', characterId: null, promptText: '', options: [] }, Weather: { title: 'Weather', condition: WEATHER_CONDITION_OPTIONS[0] },
                Time: { title: 'Time', time: '12:00 PM' },
                Sound: { title: 'Sound', selectedSoundPath: null, selectedSoundDisplayName: null, soundSearchTerm: ''},
                Delay: { title: 'Delay', delaySeconds: 1.0 },
                Terminate: { title: 'Terminate Path' }
            };
            const newNode = { id: generateId(), type: type, x: x, y: y, properties: { ...baseProps[type], ...properties }, zIndex: highestZIndex++ };
            if (type === 'Character') { // Ensure replaceKey is generated for new characters
                newNode.properties.replaceKey = generateCharacterReplaceKey(newNode.properties.name);
            }
            nodes.push(newNode); createNodeElement(newNode);
            if (type === 'Character') updateAllCharacterDependentNodes(); // Update nodes if a character was added
            updateAllWireColors(); // Recalculate wire colors as graph structure changed
            redrawWires(); // Redraw to apply new colors if any wires were affected implicitly
            attemptSaveGraphToCookies(); return newNode;
        }

        function selectNode(nodeId) {
            if (selectedNodeId && selectedNodeId !== nodeId) { // Deselect previous
                document.getElementById(selectedNodeId)?.classList.remove('selected');
            }
            if (nodeId) { // Select new
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    const node = findNodeById(nodeId);
                    if (node) { node.zIndex = highestZIndex++; nodeEl.style.zIndex = node.zIndex; } // Bring to front
                }
                selectedNodeId = nodeId;
            } else selectedNodeId = null; // Deselect all
        }

        function deleteSelectedNode() {
            if (!selectedNodeId) return;
            const nodeToRemove = findNodeById(selectedNodeId);
            document.getElementById(selectedNodeId)?.remove(); // Remove from DOM
            nodes = nodes.filter(n => n.id !== selectedNodeId); // Remove from nodes array
            wires = wires.filter(w => w.fromNode !== selectedNodeId && w.toNode !== selectedNodeId); // Remove connected wires
            if (nodeToRemove && nodeToRemove.type === 'Character') { // If a character node was deleted
                nodes.filter(n => n.type === 'Scene').forEach(sceneNode => { // Update all scene nodes
                    const sceneEl = document.getElementById(sceneNode.id);
                    if (sceneEl) updateSceneCharacterPorts(sceneNode, sceneEl);
                });
                updateAllCharacterDependentNodes(); // Update other dependent nodes
            }
            updateAllWireColors(); // Recalculate all wire colors
            redrawWires(); selectedNodeId = null; attemptSaveGraphToCookies();
        }

        function findNodeById(id) { return nodes.find(n => n.id === id); }

        function updateAllCharacterDependentNodes() {
            // Re-render content of nodes that might display character names (Dialogue, Interact, Directive)
            nodes.forEach(node => {
                if (['Dialogue', 'Interact', 'Directive'].includes(node.type)) {
                    const nodeEl = document.getElementById(node.id);
                    const contentEl = nodeEl?.querySelector('.node-content');
                    if (nodeEl && contentEl) {
                        const isExpanded = contentEl.classList.contains('expanded'); // Preserve expanded state
                        renderNodeSpecificContent(node, contentEl, nodeEl);
                        if (isExpanded && (node.type === 'Dialogue' || node.type === 'Interact')) {
                             contentEl.classList.add('expanded');
                             const advToggle = contentEl.querySelector('button.text-blue-600');
                             if (advToggle) advToggle.textContent = 'Advanced Options ▲';
                        }
                    }
                }
            });
        }

        // --- NEW/MODIFIED Wire Coloring Logic ---
        function getNewPathColor() {
            const color = wireColors[globalColorPickerIndex % wireColors.length];
            globalColorPickerIndex++;
            return color;
        }

        function _traceAndColorRecursive(nodeId, currentColor, processedWiresThisSession, visitedNodesThisTrace) {
            if (visitedNodesThisTrace.has(nodeId)) {
                return; // Cycle detected for this specific trace, stop to prevent infinite loop
            }
            visitedNodesThisTrace.add(nodeId);

            const node = findNodeById(nodeId);
            if (!node) return;

            const outgoingPathsToTrace = []; // Stores objects: { nextNodeId, colorForNextSegment }

            if (node.type === 'Scene') {
                const wireOut = wires.find(w => w.fromNode === nodeId && w.fromPort === 'narrative-out');
                if (wireOut && !processedWiresThisSession.has(wireOut.id)) {
                    wireCalculatedColors.set(wireOut.id, currentColor);
                    processedWiresThisSession.add(wireOut.id);
                    outgoingPathsToTrace.push({ nextNodeId: wireOut.toNode, colorForNextSegment: currentColor });
                }
            } else if (node.type === 'Directive') {
                node.properties.options.forEach(opt => {
                    const optionWire = wires.find(w => w.fromNode === nodeId && w.fromPort === `option-${opt.id}`);
                    if (optionWire && !processedWiresThisSession.has(optionWire.id)) {
                        const branchColor = getNewPathColor(); // Each directive option starts a new color
                        wireCalculatedColors.set(optionWire.id, branchColor);
                        processedWiresThisSession.add(optionWire.id);
                        outgoingPathsToTrace.push({ nextNodeId: optionWire.toNode, colorForNextSegment: branchColor });
                    }
                });
            } else if (['Dialogue', 'Interact', 'Weather', 'Time', 'Sound', 'Delay'].includes(node.type)) {
                // For other nodes with a single 'general-output'
                const wireOut = wires.find(w => w.fromNode === nodeId && w.fromPort === 'general-output');
                if (wireOut && !processedWiresThisSession.has(wireOut.id)) {
                    wireCalculatedColors.set(wireOut.id, currentColor);
                    processedWiresThisSession.add(wireOut.id);
                    outgoingPathsToTrace.push({ nextNodeId: wireOut.toNode, colorForNextSegment: currentColor });
                }
            }
            // Character and Terminate nodes do not propagate colors further in this logic

            // Recursively trace for all identified outgoing paths
            outgoingPathsToTrace.forEach(path => {
                _traceAndColorRecursive(path.nextNodeId, path.colorForNextSegment, processedWiresThisSession, new Set(visitedNodesThisTrace));
            });
        }

        function updateAllWireColors() {
            wireCalculatedColors.clear();
            globalColorPickerIndex = 0; // Reset color picker for each full recalculation
            const processedWiresInTotal = new Set(); // Track wires processed in this entire session to avoid re-processing

            // Start tracing from all Scene nodes, as they are primary path initiators
            nodes.filter(n => n.type === 'Scene').forEach(sceneNode => {
                 // Check if the first wire from this scene has already been colored by another path (shouldn't happen with scenes but good check)
                const sceneOutputWire = wires.find(w => w.fromNode === sceneNode.id && w.fromPort === 'narrative-out');
                if (sceneOutputWire && processedWiresInTotal.has(sceneOutputWire.id)) {
                    return; // Already handled
                }
                _traceAndColorRecursive(sceneNode.id, getNewPathColor(), processedWiresInTotal, new Set());
            });

            // Handle nodes that might start paths but are not Scenes (e.g., orphaned nodes or complex sub-graphs)
            // This ensures that even if a node isn't connected to a Scene, its outgoing paths get colored.
            nodes.filter(n => n.type !== 'Scene' && n.type !== 'Character' && n.type !== 'Terminate').forEach(node => {
                // Check if this node is a starting point of a path segment not yet colored
                // A node is a starting point if it has no 'general-input' wire connected to it,
                // or if it's a Directive and its option wires haven't been processed.
                const hasGeneralInput = wires.some(w => w.toNode === node.id && (w.toPort === 'general-input'));

                if (!hasGeneralInput) { // If no incoming wire to general input, it might be a start of a new path segment
                    let startsNewPathSegment = false;
                    if (node.type === 'Directive') {
                        // If any of its option wires haven't been processed, it's a new path start from those options
                        if (node.properties.options.some(opt => {
                            const optWire = wires.find(w => w.fromNode === node.id && w.fromPort === `option-${opt.id}`);
                            return optWire && !processedWiresInTotal.has(optWire.id);
                        })) {
                            startsNewPathSegment = true;
                        }
                    } else {
                        // For other nodes, if their general output wire hasn't been processed
                        const generalOutputWire = wires.find(w => w.fromNode === node.id && w.fromPort === 'general-output');
                        if (generalOutputWire && !processedWiresInTotal.has(generalOutputWire.id)) {
                            startsNewPathSegment = true;
                        }
                    }

                    if (startsNewPathSegment) {
                        // For directives, the color is assigned per branch in _traceAndColorRecursive.
                        // For others, assign a new color for this "orphan" path.
                        const initialColorForOrphanPath = (node.type === 'Directive') ? 'directive_placeholder' : getNewPathColor();
                        _traceAndColorRecursive(node.id, initialColorForOrphanPath, processedWiresInTotal, new Set());
                    }
                }
            });

            // Fallback for any wires that somehow didn't get colored (e.g. wires to non-existent nodes after a bad load)
            wires.forEach(wire => {
                if (!wireCalculatedColors.has(wire.id)) {
                    wireCalculatedColors.set(wire.id, '#AAAAAA'); // A neutral fallback color
                }
            });
        }
        // --- END NEW Wire Coloring Logic ---


        function redrawWires() {
            wiresSvg.innerHTML = ''; // Clear existing wires
            const graphCanvasRect = graphCanvas.getBoundingClientRect();
            wires.forEach(wire => {
                const fromNodeEl = document.getElementById(wire.fromNode), toNodeEl = document.getElementById(wire.toNode);
                // Ensure both source and target nodes exist in the DOM
                if (!fromNodeEl || !toNodeEl) {
                    return;
                }
                const fromPortEl = fromNodeEl.querySelector(`.node-port[data-port-id="${wire.fromPort}"]`), toPortEl = toNodeEl.querySelector(`.node-port[data-port-id="${wire.toPort}"]`);
                // Ensure both source and target ports exist on the nodes
                if (!fromPortEl || !toPortEl) {
                    return;
                }

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                const fromPortRect = fromPortEl.getBoundingClientRect(), toPortRect = toPortEl.getBoundingClientRect();
                // Calculate wire start/end points relative to the worldContainer (taking pan and zoom into account)
                const x1w = (fromPortRect.left + fromPortRect.width/2 - graphCanvasRect.left - panX)/currentZoom;
                const y1w = (fromPortRect.top + fromPortRect.height/2 - graphCanvasRect.top - panY)/currentZoom;
                const x2w = (toPortRect.left + toPortRect.width/2 - graphCanvasRect.left - panX)/currentZoom;
                const y2w = (toPortRect.top + toPortRect.height/2 - graphCanvasRect.top - panY)/currentZoom;
                const dx = Math.abs(x1w - x2w) * 0.5; // Control point offset for bezier curve
                line.setAttribute('d', `M ${x1w} ${y1w} C ${x1w + dx} ${y1w}, ${x2w - dx} ${y2w}, ${x2w} ${y2w}`);
                line.classList.add('wire');

                // MODIFIED: Use calculated color from wireCalculatedColors map
                const wireColor = wireCalculatedColors.get(wire.id) || (darkModeEnabled ? '#9ca3af' : '#6b7280'); // Fallback to theme default
                line.style.stroke = wireColor;
                wiresSvg.appendChild(line);
            });
        }

        function stopWiring() {
            isWiring = false; startPort = null;
            if (tempWire) { tempWire.remove(); tempWire = null; }
            document.body.style.cursor = 'default'; // Reset cursor
        }


        graphCanvas.addEventListener('mousedown', (e) => {
            // Start panning if mousedown on canvas background
            if (e.target === graphCanvas || e.target === worldContainer) {
                isPanning = true; lastPanPosition = { x: e.clientX, y: e.clientY };
                graphCanvas.style.cursor = 'grabbing'; selectNode(null); hideContextMenu();
            }
        });

        document.addEventListener('mousemove', (e) => {
            lastMouseScreenX = e.clientX; lastMouseScreenY = e.clientY; // Store last mouse position
            if (selectedElement && !isWiring) { // Dragging a node
                e.preventDefault(); const rect = graphCanvas.getBoundingClientRect();
                // Calculate new node position in world coordinates
                const newWorldX = (e.clientX - rect.left - panX) / currentZoom - offset.x;
                const newWorldY = (e.clientY - rect.top - panY) / currentZoom - offset.y;
                const node = findNodeById(selectedElement.id);
                if (node) { node.x = newWorldX; node.y = newWorldY; }
                selectedElement.style.left = `${newWorldX}px`; selectedElement.style.top = `${newWorldY}px`;
                redrawWires(); // Redraw wires as node moves
            } else if (isPanning) { // Panning the canvas
                e.preventDefault(); const dx = e.clientX - lastPanPosition.x, dy = e.clientY - lastPanPosition.y;
                panX += dx; panY += dy; lastPanPosition = { x: e.clientX, y: e.clientY };
                updateWorldTransform(); redrawWires();
            } else if (isWiring && tempWire && startPort) { // Drawing a temporary wire
                e.preventDefault(); const fromRect = startPort.getBoundingClientRect(), graphRect = graphCanvas.getBoundingClientRect();
                // Calculate temp wire end point in world coordinates
                const x1w = (fromRect.left + fromRect.width/2 - graphRect.left - panX)/currentZoom;
                const y1w = (fromRect.top + fromRect.height/2 - graphRect.top - panY)/currentZoom;
                const mouseWorld = getGraphCoordinates(e.clientX, e.clientY);
                tempWire.setAttribute('x1', x1w); tempWire.setAttribute('y1', y1w);
                tempWire.setAttribute('x2', mouseWorld.x); tempWire.setAttribute('y2', mouseWorld.y);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (selectedElement) { selectedElement.style.cursor = 'grab'; selectedElement = null; attemptSaveGraphToCookies(); }
            if (isPanning) { isPanning = false; graphCanvas.style.cursor = 'grab'; }
            // If wiring and mouseup is not on a port, stop wiring (mouseup on port is handled by port's listener)
            if (isWiring && !e.target.classList.contains('node-port')) stopWiring();
        });

        graphCanvas.addEventListener('wheel', (e) => { // Zooming
            e.preventDefault(); const speed = 0.05, oldZoom = currentZoom;
            const rect = graphCanvas.getBoundingClientRect();
            // Calculate mouse position in viewport coordinates
            const mouseVX = e.clientX - rect.left, mouseVY = e.clientY - rect.top;
            // Calculate mouse position in world coordinates before zoom
            const mouseWXBefore = (mouseVX - panX) / oldZoom, mouseWYBefore = (mouseVY - panY) / oldZoom;
            // Apply zoom
            currentZoom = e.deltaY < 0 ? Math.min(currentZoom + speed * currentZoom, 3) : Math.max(currentZoom - speed * currentZoom, 0.1);
            // Adjust pan to keep mouse position in world coordinates the same after zoom (zoom towards mouse)
            panX = mouseVX - mouseWXBefore * currentZoom; panY = mouseVY - mouseWYBefore * currentZoom;
            updateWorldTransform(); redrawWires();
        }, { passive: false }); // passive:false to allow preventDefault


        function initializeLeftPanel() {
            NODE_TYPES.forEach(type => {
                const el = document.createElement('div'); el.classList.add('panel-node-type');
                el.textContent = type; el.draggable = true; el.dataset.nodeType = type;
                el.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', type); e.dataTransfer.effectAllowed = 'copy'; });
                leftPanel.appendChild(el);
            });
        }
        graphCanvas.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
        graphCanvas.addEventListener('drop', (e) => {
            e.preventDefault(); const nodeType = e.dataTransfer.getData('text/plain');
            if (NODE_TYPES.includes(nodeType)) {
                const worldCoords = getGraphCoordinates(e.clientX, e.clientY);
                addNodeToGraph(nodeType, worldCoords.x, worldCoords.y);
            }
        });


        let contextMenuTargetNodeId = null;
        function showContextMenu(menuItems, screenX, screenY) {
            contextMenu.innerHTML = ''; // Clear previous items
            menuItems.forEach(item => {
                const miEl = document.createElement('div'); miEl.classList.add('context-menu-item');
                miEl.textContent = item.label;
                miEl.addEventListener('click', () => { item.action(); hideContextMenu(); });
                contextMenu.appendChild(miEl);
            });
            contextMenu.style.left = `${screenX}px`; contextMenu.style.top = `${screenY}px`;
            contextMenu.classList.remove('hidden');
        }
        function populateAndShowAddNodeMenu(worldX, worldY, screenX, screenY) { // Context menu for adding nodes
            const items = NODE_TYPES.map(type => ({ label: `Add ${type} Node`, action: () => addNodeToGraph(type, worldX, worldY) }));
            showContextMenu(items, screenX, screenY);
        }
        graphCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); hideContextMenu(); // Hide any existing menu
            const targetNodeEl = e.target.closest('.node');
            const worldCoords = getGraphCoordinates(e.clientX, e.clientY);
            let menuItems = [];
            if (targetNodeEl) { // Right-clicked on a node
                contextMenuTargetNodeId = targetNodeEl.id; selectNode(contextMenuTargetNodeId);
                menuItems.push({ label: 'Delete Node', action: () => deleteSelectedNode() });
                menuItems.push({ label: 'Duplicate Node', action: () => duplicateNode(contextMenuTargetNodeId) });
                if (findNodeById(contextMenuTargetNodeId)?.type !== 'Scene') { // "Read Story" not for Scene nodes
                     menuItems.push({ label: 'Read Story Up To Here', action: () => displayStoryToNode(contextMenuTargetNodeId) });
                }
                showContextMenu(menuItems, e.clientX, e.clientY);
            } else { // Right-clicked on canvas background
                contextMenuTargetNodeId = null;
                populateAndShowAddNodeMenu(worldCoords.x, worldCoords.y, e.clientX, e.clientY);
            }
        });
        function hideContextMenu() { contextMenu.classList.add('hidden'); contextMenuTargetNodeId = null; }
        function duplicateNode(nodeId) {
            const originalNode = findNodeById(nodeId); if (!originalNode) return;
            const newNodeProps = JSON.parse(JSON.stringify(originalNode.properties)); // Deep copy properties
            addNodeToGraph(originalNode.type, originalNode.x + 20/currentZoom, originalNode.y + 20/currentZoom, newNodeProps);
        }


        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { // Ctrl+S or Cmd+S for saving
                e.preventDefault();
                if (alwaysDownloadOnSave) { showToast("Downloading graph as JSON file..."); downloadGraphAsJson(); }
                else {
                    const saveResult = attemptSaveGraphToCookies();
                    if (saveResult === 'saved_single') showToast("Graph saved to cookies!");
                    else if (saveResult === 'saved_sliced') showToast(`Graph saved in ${parseInt(getCookie(GRAPH_DATA_SLICES_COOKIE) || '0')} cookie(s).`);
                    else if (saveResult === 'save_failed_too_large') { showToast("Graph too large for cookies. Downloading instead."); downloadGraphAsJson(); }
                }
                return;
            }

            // Ignore keydowns if an input field is focused
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedNode();
            if (e.key === 'Escape') { // Escape key closes modals/panels, deselects node
                settingsPanel.classList.toggle('open');
                readStoryModal.classList.add('hidden');
                hideContextMenu();
                selectNode(null);
            }
            if (e.shiftKey && (e.key === 'A' || e.key === 'a')) { // Shift+A to open "add node" context menu
                e.preventDefault(); const worldCoords = getGraphCoordinates(lastMouseScreenX, lastMouseScreenY);
                populateAndShowAddNodeMenu(worldCoords.x, worldCoords.y, lastMouseScreenX, lastMouseScreenY);
            }
        });


        function checkSavedGraph() { // Check if any graph data exists in cookies
            return getCookie(GRAPH_DATA_SLICES_COOKIE) || getCookie(`${GRAPH_DATA_COOKIE_PREFIX}0`) || getCookie('storyGraphData');
        }

        newStoryBtn.addEventListener('click', () => {
            if (checkSavedGraph()) { // If a graph is saved, ask for confirmation
                confirmNewGraphModal.classList.remove('hidden');
                backupCurrentGraphCheckbox.checked = true; // Default to backing up
            } else { // No saved graph, just start fresh
                clearGraph();
                addNodeToGraph('Scene', 50, 50); // Add a default Scene node
                startupModal.classList.add('hidden');
                attemptSaveGraphToCookies();
            }
        });

        confirmNewGraphCancelBtn.addEventListener('click', () => {
            confirmNewGraphModal.classList.add('hidden');
        });

        confirmNewGraphConfirmBtn.addEventListener('click', () => {
            if (backupCurrentGraphCheckbox.checked) {
                const backupSuccess = downloadSavedGraphFromCookies();
            }
            clearGraph();
            addNodeToGraph('Scene', 50, 50);
            startupModal.classList.add('hidden');
            confirmNewGraphModal.classList.add('hidden');
            attemptSaveGraphToCookies();
        });


        openSavedStoryBtn.addEventListener('click', () => {
            loadGraphFromCookies();
            startupModal.classList.add('hidden');
        });

        clearSavedGraphBtn.addEventListener('click', () => {
            deleteCookiesByPrefix(GRAPH_DATA_COOKIE_PREFIX);
            deleteCookie(GRAPH_DATA_SLICES_COOKIE);
            deleteCookie('storyGraphData'); // Legacy single cookie
            showToast("Saved graph data cleared from cookies.");
            const openSavedBtnInModal = document.querySelector('#startup-modal #open-saved-story-btn');
            if (openSavedBtnInModal && !checkSavedGraph()) { // Hide "Open Saved" if no graph exists
                openSavedBtnInModal.classList.add('hidden');
            }
        });



        function attemptSaveGraphToCookies() {
            const graphData = {
                nodes: nodes, wires: wires, panX: panX, panY: panY, currentZoom: currentZoom,
                highestZIndex: highestZIndex, storyTitle: storyTitle, storyAuthor: storyAuthor, storyTags: storyTags
            };
            try {
                const jsonString = JSON.stringify(graphData);
                const encodedJsonString = encodeURIComponent(jsonString); // URI encode for cookie safety
                if (encodedJsonString.length <= COOKIE_SLICE_MAX_LENGTH) { // Small enough for one cookie
                    deleteCookiesByPrefix(GRAPH_DATA_COOKIE_PREFIX); deleteCookie(GRAPH_DATA_SLICES_COOKIE); // Clear old slices
                    setCookie(`${GRAPH_DATA_COOKIE_PREFIX}0`, encodedJsonString, 365);
                    setCookie(GRAPH_DATA_SLICES_COOKIE, '1', 365); // Record number of slices
                    return 'saved_single';
                } else { // Too large, need to slice
                    const numSlices = Math.ceil(encodedJsonString.length / COOKIE_SLICE_MAX_LENGTH);
                    if (numSlices > MAX_COOKIE_SLICES) return 'save_failed_too_large'; // Exceeds max slices
                    deleteCookiesByPrefix(GRAPH_DATA_COOKIE_PREFIX); deleteCookie(GRAPH_DATA_SLICES_COOKIE); // Clear old slices
                    for (let i = 0; i < numSlices; i++) {
                        setCookie(`${GRAPH_DATA_COOKIE_PREFIX}${i}`, encodedJsonString.substring(i*COOKIE_SLICE_MAX_LENGTH, (i+1)*COOKIE_SLICE_MAX_LENGTH), 365);
                    }
                    setCookie(GRAPH_DATA_SLICES_COOKIE, numSlices.toString(), 365);
                    return 'saved_sliced';
                }
            } catch (error) { console.error("Error saving graph to cookies:", error); return 'error'; }
        }

        function downloadSavedGraphFromCookies() { // For backing up before starting new
            let fullEncodedJsonString = "";
            const numSlicesStr = getCookie(GRAPH_DATA_SLICES_COOKIE);
            if (numSlicesStr) { // Sliced cookie format
                const numSlices = parseInt(numSlicesStr, 10);
                if (!isNaN(numSlices) && numSlices > 0) {
                    for (let i = 0; i < numSlices; i++) {
                        const slice = getCookie(`${GRAPH_DATA_COOKIE_PREFIX}${i}`);
                        if (slice) {
                            fullEncodedJsonString += slice;
                        } else {
                            showToast("Error: Incomplete saved graph data in cookies for backup.");
                            return false; // Missing a slice
                        }
                    }
                }
            } else { // Try legacy single cookie format
                fullEncodedJsonString = getCookie(`${GRAPH_DATA_COOKIE_PREFIX}0`) || getCookie('storyGraphData') || "";
            }

            if (fullEncodedJsonString) {
                try {
                    const decodedJsonString = decodeURIComponent(fullEncodedJsonString);
                    const graphDataForFile = JSON.parse(decodedJsonString);

                    // Prepare data for download, including preferences
                    const dataToDownload = {
                        nodes: graphDataForFile.nodes || [],
                        wires: graphDataForFile.wires || [],
                        panX: graphDataForFile.panX || 0,
                        panY: graphDataForFile.panY || 0,
                        currentZoom: graphDataForFile.currentZoom || 1,
                        highestZIndex: graphDataForFile.highestZIndex || 1,
                        storyTitle: graphDataForFile.storyTitle || "story_graph_backup",
                        storyAuthor: graphDataForFile.storyAuthor || "",
                        storyTags: graphDataForFile.storyTags || "",
                        // Include current user preferences in the backup
                        darkMode: getPreference(PREF_DARK_MODE, false),
                        alwaysDownloadOnSave: getPreference(PREF_ALWAYS_DOWNLOAD, false)
                    };
                    // Override with preferences from file if they exist (though less likely for cookie backup)
                    if (typeof graphDataForFile.darkMode === 'boolean') {
                        dataToDownload.darkMode = graphDataForFile.darkMode;
                    }
                    if (typeof graphDataForFile.alwaysDownloadOnSave === 'boolean') {
                        dataToDownload.alwaysDownloadOnSave = graphDataForFile.alwaysDownloadOnSave;
                    }


                    const titleForFile = dataToDownload.storyTitle;
                    const finalJsonStringToDownload = JSON.stringify(dataToDownload, null, 2);

                    const blob = new Blob([finalJsonStringToDownload], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${titleForFile.toLowerCase().replace(/\s+/g, '_')}_saved_backup.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast("Saved graph from cookies backed up.");
                    return true;
                } catch (error) {
                    console.error("Error processing saved graph from cookies for backup:", error);
                    showToast("Error: Could not backup saved graph. Data might be corrupted.");
                    return false;
                }
            } else {
                showToast("No saved graph data found in cookies to backup.");
                return false;
            }
        }


        function downloadGraphAsJson() { // Download current editor state
            const graphDataToDownload = {
                nodes, wires, panX, panY, currentZoom, highestZIndex, storyTitle, storyAuthor, storyTags,
                darkMode: darkModeEnabled, // Include current preferences
                alwaysDownloadOnSave: alwaysDownloadOnSave
            };
            const jsonString = JSON.stringify(graphDataToDownload, null, 2); // Pretty print JSON
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url;
            a.download = `${(storyTitle || 'story_graph').toLowerCase().replace(/\s+/g, '_')}_editor_data.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function loadGraphFromData(graphData, isLoadingFromFile = false) {
            // Clear current graph state
            nodes = []; wires = [];
            worldContainer.querySelectorAll('.node').forEach(n => n.remove());
            wiresSvg.innerHTML = '';
            selectedNodeId = null; panX = 0; panY = 0; currentZoom = 1; highestZIndex = 1;

            // Load data from provided object
            nodes = graphData.nodes || [];
            wires = graphData.wires || [];
            panX = graphData.panX || 0;
            panY = graphData.panY || 0;
            currentZoom = graphData.currentZoom || 1;
            highestZIndex = graphData.highestZIndex || (nodes.length + 1);

            // Load story metadata
            storyTitle = graphData.storyTitle || "My Awesome Story";
            storyAuthor = graphData.storyAuthor || "";
            storyTags = graphData.storyTags || "";
            storyTitleInput.value = storyTitle;
            storyAuthorInput.value = storyAuthor;
            storyTagsInput.value = storyTags;

            // If loading from a file, also load preferences from the file
            if (isLoadingFromFile) {
                if (typeof graphData.darkMode === 'boolean') {
                    darkModeEnabled = graphData.darkMode;
                    applyDarkModePreference();
                    savePreference(PREF_DARK_MODE, darkModeEnabled); // Save loaded preference
                }
                if (typeof graphData.alwaysDownloadOnSave === 'boolean') {
                    alwaysDownloadOnSave = graphData.alwaysDownloadOnSave;
                    applyAlwaysDownloadPreference();
                    savePreference(PREF_ALWAYS_DOWNLOAD, alwaysDownloadOnSave); // Save loaded preference
                }
            }

            updateWorldTransform(); // Apply pan and zoom

            // Recreate node elements
            nodes.forEach(node => {
                node.zIndex = node.zIndex || highestZIndex++; // Ensure zIndex is set
                if (node.type === 'Character' && (!node.properties.replaceKey || node.properties.replaceKey === '_NEW_CHAR' || node.properties.replaceKey === '_CHARACTER_A')) {
                    node.properties.replaceKey = generateCharacterReplaceKey(node.properties.name);
                }
                const el = createNodeElement(node);
                if (node.properties.isExpanded && el.querySelector('.expandable-content')) {
                    el.querySelector('.node-content').classList.add('expanded');
                    const advToggle = el.querySelector('.node-content button.text-blue-600');
                    if (advToggle) advToggle.textContent = 'Advanced Options ▲';
                }
            });
            updateAllWireColors(); // Calculate and assign colors for all wires
            redrawWires(); // Redraw with new colors
        }

        function loadGraphFromCookies() {
            let fullEncodedJsonString = "";
            const numSlicesStr = getCookie(GRAPH_DATA_SLICES_COOKIE);
            if (numSlicesStr) { // Sliced cookie format
                const numSlices = parseInt(numSlicesStr, 10);
                if (!isNaN(numSlices) && numSlices > 0) {
                    for (let i = 0; i < numSlices; i++) {
                        const slice = getCookie(`${GRAPH_DATA_COOKIE_PREFIX}${i}`);
                        if (slice) fullEncodedJsonString += slice;
                        else { fullEncodedJsonString = ""; break; } // Missing slice
                    }
                }
            } else { // Try legacy single cookie format
                 fullEncodedJsonString = getCookie(`${GRAPH_DATA_COOKIE_PREFIX}0`) || getCookie('storyGraphData') || "";
            }

            if (fullEncodedJsonString) {
                try {
                    const decodedJsonString = decodeURIComponent(fullEncodedJsonString);
                    const graphData = JSON.parse(decodedJsonString);
                    loadGraphFromData(graphData, false); // false: not loading from file
                } catch (error) {
                    console.error("Error parsing saved graph from cookies:", error);
                    showToast("Error: Could not load saved story. Data might be corrupted.");
                }
            } else if (numSlicesStr && parseInt(numSlicesStr,10) > 0) { // Incomplete sliced data
                 showToast("Error: Could not load saved story. Cookie data seems incomplete.");
            }
        }

        function clearGraph() { // Reset the graph to an empty state
            nodes = []; wires = [];
            worldContainer.querySelectorAll('.node').forEach(n => n.remove());
            wiresSvg.innerHTML = '';
            selectedNodeId = null; panX = 0; panY = 0; currentZoom = 1; highestZIndex = 1;
            // Reset story metadata
            storyTitle = "My Awesome Story"; storyAuthor = ""; storyTags = "";
            storyTitleInput.value = storyTitle;
            storyAuthorInput.value = storyAuthor;
            storyTagsInput.value = storyTags;
            updateAllWireColors(); // Update for the cleared state
            updateWorldTransform(); redrawWires();
        }


        function deleteCookie(name) { document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT; SameSite=Lax'; }
        function deleteCookiesByPrefix(prefix) {
            const cookies = document.cookie.split(';');
            for (let c of cookies) {
                const eqPos = c.indexOf("=");
                const name = eqPos > -1 ? c.substr(0, eqPos).trim() : c.trim();
                if (name.startsWith(prefix)) deleteCookie(name);
            }
        }
        function setCookie(name, value, days) {
            let expires = ""; if (days) { const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); expires = "; expires="+d.toUTCString(); }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }
        function getCookie(name) {
            const nameEQ = name + "="; const ca = document.cookie.split(';');
            for(let c of ca) { while (c.charAt(0)==' ') c = c.substring(1,c.length); if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length); }
            return null;
        }


        storyTitleInput.addEventListener('input', (e) => { storyTitle = e.target.value; attemptSaveGraphToCookies(); });
        storyAuthorInput.addEventListener('input', (e) => { storyAuthor = e.target.value; attemptSaveGraphToCookies(); });
        storyTagsInput.addEventListener('input', (e) => { storyTags = e.target.value; attemptSaveGraphToCookies(); });

        function applyDarkModePreference() {
            if (darkModeEnabled) document.body.classList.add('dark');
            else document.body.classList.remove('dark');
            darkModeToggle.checked = darkModeEnabled;
            // Update toggle switch visual
            const dot = darkModeToggle.closest('label').querySelector('.dot');
            if (dot) dot.style.transform = darkModeEnabled ? 'translateX(100%)' : 'translateX(0%)';
            redrawWires(); // Redraw wires as default fallback color might change
        }
        function applyAlwaysDownloadPreference() {
            alwaysDownloadToggle.checked = alwaysDownloadOnSave;
            const dot = alwaysDownloadToggle.closest('label').querySelector('.dot');
            if (dot) dot.style.transform = alwaysDownloadOnSave ? 'translateX(100%)' : 'translateX(0%)';
        }

        darkModeToggle.addEventListener('change', () => {
            darkModeEnabled = darkModeToggle.checked;
            applyDarkModePreference();
            savePreference(PREF_DARK_MODE, darkModeEnabled);
        });
        alwaysDownloadToggle.addEventListener('change', () => {
            alwaysDownloadOnSave = alwaysDownloadToggle.checked;
            applyAlwaysDownloadPreference();
            savePreference(PREF_ALWAYS_DOWNLOAD, alwaysDownloadOnSave);
        });

        exportGraphJsonBtn.addEventListener('click', downloadGraphAsJson);

        // --- Story Reading Logic ---
        function displayStoryToNode(targetNodeId) {
            if (!targetNodeId) return;
            storyPathDisplay.innerHTML = ''; // Clear previous content

            try { // Wrap path generation and display in a try-catch
                const allPaths = traceAllPathsToNode(targetNodeId);

                if (allPaths.length === 0) {
                    storyPathDisplay.innerHTML = '<p>No narrative path found to this node from a Scene node, or the target node is not part of a traceable path.</p>';
                } else {
                    allPaths.forEach((path, index) => {
                        if (allPaths.length > 1) {
                            storyPathDisplay.innerHTML += `<h3 class="text-lg font-semibold mt-2 mb-1">Path ${index + 1}:</h3>`;
                        }
                        let pathHtml = '';
                        path.nodes.forEach((nodeId, nodeIndex) => {
                            const node = findNodeById(nodeId);
                            if (!node) {
                                pathHtml += '<p class="mb-1 text-red-500"><strong>Error:</strong> Referenced node not found in path.</p>';
                                return;
                            }

                            pathHtml += `<p class="mb-1"><strong>${node.type}:</strong> `;
                            if (node.title && node.type !== 'Scene' && node.properties && node.properties.title !== node.type) {
                                pathHtml += `<em>${node.title}</em> - `;
                            }

                            if (!node.properties) { // Defensive check for properties object
                                pathHtml += `(Error: Node properties missing for ${node.id})</p>`;
                                return;
                            }

                            switch (node.type) {
                                case 'Scene':
                                    pathHtml += `Location: ${node.properties.title || 'Unnamed Scene'}`;
                                    break;
                                case 'Dialogue':
                                    const charDia = node.properties.characterId ? findNodeById(node.properties.characterId) : null;
                                    pathHtml += `${charDia && charDia.properties ? charDia.properties.name : 'Unknown Character'} says: "${node.properties.text || ''}"`;
                                    break;
                                case 'Interact':
                                    const charInt = node.properties.characterId ? findNodeById(node.properties.characterId) : null;
                                    pathHtml += `${charInt && charInt.properties ? charInt.properties.name : 'Unknown Character'} prompts: "${node.properties.promptText || ''}" (Player provides: ${node.properties.placeholder || 'input'})`;
                                    break;
                                case 'Directive':
                                    const charDir = node.properties.characterId ? findNodeById(node.properties.characterId) : null;
                                    pathHtml += `${charDir && charDir.properties ? charDir.properties.name : 'Unknown Character'} faces situation: "${node.properties.promptText || ''}"`;
                                    const decisionSummary = path.decisions.find(d => d.directiveId === nodeId);
                                    if (decisionSummary) {
                                        pathHtml += `<br><span class="ml-4 text-sm text-gray-600 dark:text-gray-400">&rarr; Chose: "${decisionSummary.summary || 'Unnamed Option'}"</span>`;
                                    }
                                    break;
                                case 'Weather': pathHtml += `Condition: ${node.properties.condition || 'Not set'}`; break;
                                case 'Time': pathHtml += `Time set to: ${node.properties.time || 'Not set'}`; break;
                                case 'Sound': pathHtml += `Sound: ${node.properties.selectedSoundDisplayName || 'No sound selected'}`; break;
                                case 'Delay': pathHtml += `Delay for: ${node.properties.delaySeconds || '0'}s`; break;
                                case 'Terminate': pathHtml += `Path Ends.`; break;
                                default: pathHtml += `(Node properties...)`; break;
                            }
                            pathHtml += '</p>';
                        });
                        storyPathDisplay.innerHTML += pathHtml;
                        if (index < allPaths.length - 1) storyPathDisplay.innerHTML += '<hr class="my-4 border-gray-300 dark:border-gray-600">';
                    });
                }
            } catch (error) {
                console.error("Error generating story path display:", error);
                storyPathDisplay.innerHTML = '<p class="text-red-500">An error occurred while generating the story path. Please check the console.</p>';
            }
            readStoryModal.classList.remove('hidden'); // Ensure modal is shown even if content generation failed
        }

        function traceAllPathsToNode(targetNodeId) {
            const allPaths = [];
            const sceneNodes = nodes.filter(n => n.type === 'Scene');

            if (sceneNodes.length === 0) { // If no scene nodes, no paths can start
                console.warn("No Scene nodes found to start tracing paths.");
                return [];
            }

            sceneNodes.forEach(sceneNode => {
                // Start DFS from each scene node
                dfsPathTrace(sceneNode.id, targetNodeId, [], [], allPaths, new Set());
            });

            // Filter paths to ensure they actually end at the targetNodeId
            // And map them to the desired structure { nodes: [], decisions: [] }
            return allPaths
                .filter(path => path.nodes.length > 0 && path.nodes[path.nodes.length - 1] === targetNodeId)
                .map(path => ({ nodes: path.nodes, decisions: path.decisions }));
        }


        function dfsPathTrace(currentNodeId, targetNodeId, currentPathNodeIds, currentPathDecisionSummaries, allPaths, visitedInCurrentPath) {
            const node = findNodeById(currentNodeId);
            if (!node || visitedInCurrentPath.has(currentNodeId)) { // Node doesn't exist or cycle detected
                return;
            }

            visitedInCurrentPath.add(currentNodeId);
            const newPathNodeIds = [...currentPathNodeIds, currentNodeId];
            let newPathDecisionSummaries = [...currentPathDecisionSummaries]; // Copy decisions so far

            if (currentNodeId === targetNodeId) { // Reached the target
                allPaths.push({ nodes: newPathNodeIds, decisions: newPathDecisionSummaries });
                visitedInCurrentPath.delete(currentNodeId); // Backtrack
                return;
            }

            if (node.type === 'Terminate') { // Path ends
                visitedInCurrentPath.delete(currentNodeId); // Backtrack
                return;
            }

            // Determine next nodes based on current node type
            let nextNodeWires = [];
            if (node.type === 'Scene') {
                nextNodeWires = wires.filter(w => w.fromNode === currentNodeId && w.fromPort === 'narrative-out');
            } else if (['Dialogue', 'Interact', 'Weather', 'Time', 'Sound', 'Delay'].includes(node.type)) {
                nextNodeWires = wires.filter(w => w.fromNode === currentNodeId && w.fromPort === 'general-output');
            } else if (node.type === 'Directive') {
                // For a directive, we explore all its options
                if (node.properties && node.properties.options) {
                    node.properties.options.forEach(option => {
                        const optionWire = wires.find(w => w.fromNode === currentNodeId && w.fromPort === `option-${option.id}`);
                        if (optionWire) {
                            // When exploring a directive's option, record which option was "taken" for this branch of the DFS
                            const decisionForThisBranch = { directiveId: currentNodeId, optionId: option.id, summary: option.summary };
                            dfsPathTrace(optionWire.toNode, targetNodeId, newPathNodeIds, [...newPathDecisionSummaries, decisionForThisBranch], allPaths, new Set(visitedInCurrentPath));
                        }
                    });
                }
                visitedInCurrentPath.delete(currentNodeId); // Backtrack after exploring all directive options
                return; // Return because directive options are handled recursively above
            }

            // For non-directive nodes that continue the path
            nextNodeWires.forEach(wire => {
                dfsPathTrace(wire.toNode, targetNodeId, newPathNodeIds, newPathDecisionSummaries, allPaths, new Set(visitedInCurrentPath));
            });

            visitedInCurrentPath.delete(currentNodeId); // Backtrack
        }
        // --- End Story Reading Logic ---


        // --- Panel Minimize/Restore Logic ---
        if (minimizePanelBtn && restorePanelBtn && leftPanel) {
            minimizePanelBtn.addEventListener('click', () => {
                leftPanel.classList.add('minimized');
                restorePanelBtn.classList.remove('hidden');
            });

            restorePanelBtn.addEventListener('click', () => {
                leftPanel.classList.remove('minimized');
                restorePanelBtn.classList.add('hidden');
            });
        }


        async function initializeApp() {
            // Fetch and process audio file list
            try {
                const response = await fetch('../assets/audio/index.php'); // Adjust path if needed
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawFileNames = await response.text();
                const fileNamesArray = rawFileNames.replace(/^\[|\]$/g, "").replaceAll("\"", "").split(',').map(name => name.trim()).filter(name => name);
                PROCESSED_SOUND_LIST = processAudioFiles(fileNamesArray);
            } catch (error) {
                console.error("Could not fetch or process audio file list:", error);
                showToast("Warning: Could not load audio file list. Sound node may be incomplete.");
                PROCESSED_SOUND_LIST = processAudioFiles([]); // Initialize with empty if fetch fails
            }


            initializeLeftPanel();
            loadPreferencesAndApply(); // Load and apply dark mode, etc.

            if (checkSavedGraph()) {
                openSavedStoryBtn.classList.remove('hidden');
            } else {
                openSavedStoryBtn.classList.add('hidden');
            }

            if (checkSavedGraph() && startupModal.classList.contains('hidden')) {
                loadGraphFromCookies();
            } else if (!checkSavedGraph() && startupModal.classList.contains('hidden')) {
                updateAllWireColors();
                redrawWires();
            }


            graphCanvas.style.cursor = 'grab'; // Set default cursor for graph canvas
            updateWorldTransform();
            if (nodes.length === 0 && wires.length === 0 && startupModal.classList.contains('hidden')) {
                 updateAllWireColors();
                 redrawWires();
            }

            // Event listener for closing Read Story modal by clicking its own backdrop
            if (readStoryModal) {
                readStoryModal.addEventListener('click', (event) => {
                    if (event.target === readStoryModal) { // Check if the click is on the backdrop itself
                        readStoryModal.classList.add('hidden');
                    }
                });
            }

            // Event listener for the dedicated close button in the Read Story modal
            if (closeReadStoryModalBtn && readStoryModal) {
                closeReadStoryModalBtn.addEventListener('click', () => {
                    readStoryModal.classList.add('hidden');
                });
            }
        }

        function loadPreferencesAndApply() {
            darkModeEnabled = getPreference(PREF_DARK_MODE, false);
            alwaysDownloadOnSave = getPreference(PREF_ALWAYS_DOWNLOAD, false);
            applyDarkModePreference();
            applyAlwaysDownloadPreference();
        }


        document.addEventListener('click', (e) => {
            if (!contextMenu.classList.contains('hidden') && !contextMenu.contains(e.target)) {
                hideContextMenu();
            }
            document.querySelectorAll('.sound-node-ui').forEach(soundUiEl => {
                const dropdownList = soundUiEl.querySelector('.sound-dropdown-list');
                const selectedDisplay = soundUiEl.querySelector('.selected-sound-display');
                if (dropdownList && !dropdownList.classList.contains('hidden') && !soundUiEl.contains(e.target)) {
                    dropdownList.classList.add('hidden');
                    if (selectedDisplay) selectedDisplay.classList.remove('open');
                    const arrow = selectedDisplay ? selectedDisplay.querySelector('.dropdown-arrow-symbol') : null;
                    if (arrow) arrow.innerHTML = '&#9660;';
                }
            });
        });

        initializeApp(); // Start the application

    </script>
</body>
</html>
