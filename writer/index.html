<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Craft GUI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; 
            display: flex; 
        }
        #left-panel {
            width: 200px;
            background-color: #e5e7eb; 
            padding: 16px;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 2000; 
        }
        .dark #left-panel {
            background-color: #374151; 
            color: #d1d5db; 
        }
        .panel-node-type {
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: #fff;
            border: 1px solid #d1d5db; 
            border-radius: 6px;
            cursor: grab;
            text-align: center;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .dark .panel-node-type {
            background-color: #4b5563; 
            border-color: #6b7280; 
        }

        #main-content-area {
            flex-grow: 1;
            position: relative; 
            height: 100vh;
            overflow: hidden; 
        }

        #graph-canvas { 
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top:0; left:0;
            overflow: hidden; 
            background-color: #f3f4f6; 
        }
        .dark #graph-canvas {
            background-color: #1f2937; 
        }

        #world-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            transform-origin: 0 0;
        }


        .node {
            position: absolute; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: grab;
            user-select: none;
            min-width: 200px; 
            transition: box-shadow 0.2s ease-in-out; 
            background-color: #fff; 
            border: 1px solid #d1d5db; 

        }
        .node-scene { 
            min-height: 80px; 
        }
        .node.selected {
            box-shadow: 0 0 0 3px #3b82f6, 0 6px 12px rgba(0,0,0,0.2); 
            z-index: 1000 !important; 
        }
        .node-title {
            padding: 8px 12px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            font-weight: 600;
            background-color: #e5e7eb; 
            color: #374151; 
        }
        .node-content {
            padding: 12px;
            font-size: 0.875rem;
            position: relative; 
        }
        .node-port {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            background-color: #9ca3af; 
            cursor: crosshair;
            transition: background-color 0.2s;
            z-index: 1; 
        }
        .node-port:hover {
            background-color: #3b82f6; 
        }
        .node-port.input { left: -6px; }
        .node-port.output { right: -6px; }
        .node-port.output-decision { right: -6px; } 

        .port-label {
            position: absolute;
            font-size: 0.65rem; 
            color: #4b5563; 
            pointer-events: none; 
            white-space: nowrap;
            line-height: 12px; 
        }
        .dark .port-label {
            color: #9ca3af; 
        }
        .port-label.input { left: 10px; transform: translateY(-50%); }
        .port-label.output { right: 10px; transform: translateY(-50%); text-align: right; }

        .dark .node {
            background-color: #374151; 
            color: #d1d5db; 
            border-color: #4b5563; 
        }
        .dark .node-title {
            background-color: #4b5563; 
            color: #f3f4f6; 
        }
        .dark .node-port {
            background-color: #6b7280; 
        }
        .dark .node-port:hover {
            background-color: #60a5fa; 
        }
        .dark .modal-content, .dark .settings-panel, .dark #read-story-modal-content {
            background-color: #374151; 
            color: #d1d5db; 
        }
         .dark #read-story-modal-content hr {
            border-color: #4b5563;
        }
        .dark input, .dark textarea, .dark select {
            background-color: #4b5563; 
            color: #d1d5db; 
            border-color: #6b7280; 
        }
        .dark button:not(.panel-node-type) { 
            background-color: #4f46e5; 
            color: white;
        }
        .dark button:not(.panel-node-type):hover {
            background-color: #4338ca; 
        }
        .dark .button-secondary {
             background-color: #4b5563; 
        }
        .dark .button-secondary:hover {
             background-color: #6b7280; 
        }


        #wires-svg { 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: none;
            overflow: visible; 
        }
        .wire {
            stroke: #6b7280; 
            stroke-width: 2.5; 
            fill: none;
            vector-effect: non-scaling-stroke; 
        }
        .dark .wire {
            stroke: #9ca3af; 
        }
        .temp-wire {
            stroke: #3b82f6; 
            stroke-width: 2.5;
            fill: none;
            stroke-dasharray: 5,5;
            vector-effect: non-scaling-stroke;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .modal-content { 
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            min-width: 300px;
            text-align: center;
        }
        #read-story-modal-content { 
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: left;
        }
        #read-story-modal-content h3 { margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600;}
        #read-story-modal-content hr { margin: 1rem 0; border-top: 1px solid #e5e7eb; }
        #read-story-modal-content p { margin-bottom: 0.5rem; white-space: pre-wrap; }
        #read-story-modal-content strong { font-weight: 600; }


        .settings-panel {
            position: fixed;
            top: 20px;
            right: -400px; 
            width: 350px;
            height: calc(100vh - 40px);
            background-color: white;
            padding: 20px;
            border-radius: 8px 0 0 8px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            z-index: 9000;
            transition: right 0.3s ease-in-out;
            overflow-y: auto;
        }
        .settings-panel.open {
            right: 0;
        }
        .settings-panel label { 
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem; 
            font-weight: 500; 
        }
        .settings-panel .toggle-label-container { 
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; 
        }
        .settings-panel .toggle-label { 
            margin-left: 0.75rem; 
            font-size: 1rem; 
            font-weight: 600; 
        }
        .settings-panel input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db; 
            border-radius: 0.375rem; 
            margin-bottom: 0.75rem;
        }
        .dark .settings-panel input[type="text"] {
            background-color: #4b5563; 
            border-color: #6b7280; 
            color: #e5e7eb; 
        }


        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #e5e7eb; 
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 10001;
            min-width: 200px; 
        }
        .dark .context-menu {
            background-color: #374151; 
            border-color: #4b5563; 
            color: #e5e7eb; 
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .context-menu-item:hover {
            background-color: #f3f4f6; 
        }
        .dark .context-menu-item:hover {
            background-color: #4b5563; 
            color: #f9fafb; 
        }
        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .expanded .expandable-content {
            max-height: 500px; 
        }
        .node-content label {
            display: block;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .node-content input[type="text"],
        .node-content textarea,
        .node-content select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db; 
            border-radius: 4px;
            font-size: 0.875rem;
            margin-bottom: 8px;
            box-sizing: border-box;
        }
        .node-content button {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-top: 4px;
        }
        /* Shared toggle switch styling */
        .toggle-switch:checked ~ .dot {
            transform: translateX(100%);
            background-color: #4f46e5; 
        }
        .toggle-switch:checked ~ .block { /* The track of the switch */
            background-color: #6d28d9; 
        }
        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 10002;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .dark .toast-notification {
            background-color: #4b5563; 
            color: #e5e7eb; 
        }
    </style>
</head>
<body class="overflow-hidden">

    <div id="left-panel">
        <h3 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-200">Nodes</h3>
        </div>

    <div id="main-content-area">
        <div id="graph-canvas">
            <div id="world-container">
                <svg id="wires-svg"></svg>
                </div>
        </div>
    </div>

    <div id="startup-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-semibold mb-6">Story Craft GUI</h2>
            <button id="new-story-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
                Begin a New Story Graph
            </button>
            <button id="open-saved-story-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg w-full hidden">
                Open Saved Graph
            </button>
        </div>
    </div>

    <div id="settings-panel" class="settings-panel">
        <h3 class="text-xl font-semibold mb-6">Settings</h3>

        <div class="mb-4">
            <label for="story-title-input">Story Name:</label>
            <input type="text" id="story-title-input" placeholder="Enter story name">
        </div>
        <div class="mb-4">
            <label for="story-author-input">Author:</label>
            <input type="text" id="story-author-input" placeholder="Enter author name">
        </div>
        <div class="mb-6"> <label for="story-tags-input">Tags (comma-separated):</label>
            <input type="text" id="story-tags-input" placeholder="e.g., romance, drama">
        </div>
        
        <div class="mb-4 border-t border-gray-300 dark:border-gray-600 pt-4 toggle-label-container"> 
            <label for="dark-mode-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="dark-mode-toggle" class="sr-only toggle-switch">
                    <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                </div>
                <div class="toggle-label">Dark Mode</div>
            </label>
        </div>
        <div class="mb-4 toggle-label-container">
             <label for="always-download-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="always-download-toggle" class="sr-only toggle-switch">
                    <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                </div>
                <span class="toggle-label">Always Download on Ctrl+S</span>
            </label>
        </div>


        <button id="export-graph-json-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
            Export Graph (Editor Format)
        </button>
        <button id="export-story-narrative-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg w-full mb-3">
            Export Story (Narrative Format)
        </button>
        
        <div class="mb-3">
            <label for="import-json-file" class="block text-sm font-medium mb-1">Import Graph (Editor Format):</label>
            <input type="file" id="import-json-file" accept=".json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100">
        </div>
        <p class="text-xs text-gray-500 dark:text-gray-400 mt-4">Press Ctrl+S to save the current graph.</p>
        <p class="text-xs text-red-500 dark:text-red-400 mt-1">Note: If graph is too large for cookies, it may download as a JSON file instead.</p>
    </div>

    <div id="context-menu" class="context-menu hidden">
        </div>
    
    <div id="read-story-modal" class="modal hidden">
        <div id="read-story-modal-content">
            <h3>Story Path</h3>
            <div id="story-path-display"></div>
            <button id="close-read-story-modal-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg mt-6">Close</button>
        </div>
    </div>


    <script>
        // --- Global State & Configuration ---
        let nodes = [];
        let wires = [];
        let selectedNodeId = null;
        let selectedElement = null; 
        let offset = { x: 0, y: 0 };
        let currentZoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanPosition = { x: 0, y: 0 };
        let lastMouseScreenX = 0; 
        let lastMouseScreenY = 0; 

        let storyTitle = "My Awesome Story";
        let storyAuthor = "";
        let storyTags = "";
        let alwaysDownloadOnSave = false;


        let isWiring = false;
        let tempWire = null;
        let startPort = null;
        let wireColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FED766', '#2AB7CA'];
        let nextWireColorIndex = 0;
        let highestZIndex = 1;

        const graphCanvas = document.getElementById('graph-canvas');
        const worldContainer = document.getElementById('world-container'); 
        const wiresSvg = document.getElementById('wires-svg');
        const startupModal = document.getElementById('startup-modal');
        const newStoryBtn = document.getElementById('new-story-btn');
        const openSavedStoryBtn = document.getElementById('open-saved-story-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const alwaysDownloadToggle = document.getElementById('always-download-toggle');
        const exportGraphJsonBtn = document.getElementById('export-graph-json-btn'); 
        const exportStoryNarrativeBtn = document.getElementById('export-story-narrative-btn');
        const importJsonFile = document.getElementById('import-json-file');
        const contextMenu = document.getElementById('context-menu');
        const leftPanel = document.getElementById('left-panel');
        const mainContentArea = document.getElementById('main-content-area');
        const readStoryModal = document.getElementById('read-story-modal');
        const storyPathDisplay = document.getElementById('story-path-display');
        const closeReadStoryModalBtn = document.getElementById('close-read-story-modal-btn');
        const storyTitleInput = document.getElementById('story-title-input');
        const storyAuthorInput = document.getElementById('story-author-input');
        const storyTagsInput = document.getElementById('story-tags-input');


        const NODE_TYPES = ['Scene', 'Character', 'Dialogue', 'Interact', 'Directive', 'Weather', 'Time'];
        const PORT_BASE_TOP_OFFSET = 28; 
        const PORT_SPACING = 25; 
        const COOKIE_SLICE_MAX_LENGTH = 3980; 
        const MAX_COOKIE_SLICES = 20; 

        // --- Utility Functions ---
        function generateId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        function getGraphCoordinates(screenX, screenY) {
            const graphCanvasRect = graphCanvas.getBoundingClientRect(); 
            return {
                x: (screenX - graphCanvasRect.left - panX) / currentZoom,
                y: (screenY - graphCanvasRect.top - panY) / currentZoom
            };
        }
        
        function updateWorldTransform() {
            worldContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
            /*
            // Set SVG viewBox to match the visible part of the world
            const viewBoxMinX = -panX / currentZoom;
            const viewBoxMinY = -panY / currentZoom;
            const viewBoxWidth = graphCanvas.clientWidth / currentZoom;
            const viewBoxHeight = graphCanvas.clientHeight / currentZoom;
            wiresSvg.setAttribute('viewBox', `${viewBoxMinX} ${viewBoxMinY} ${viewBoxWidth} ${viewBoxHeight}`);
            */
        }

        function showToast(message) {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) existingToast.remove();

            const toast = document.createElement('div');
            toast.textContent = message;
            toast.classList.add('toast-notification');
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // --- Node Management ---
        function createNodeElement(node) {
            const nodeEl = document.createElement('div');
            nodeEl.id = node.id;
            nodeEl.classList.add('node', `node-${node.type.toLowerCase()}`, 'border'); 
            if (node.type === 'Scene') nodeEl.classList.add('node-scene');

            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            
            node.zIndex = node.zIndex || highestZIndex++; 
            nodeEl.style.zIndex = node.zIndex;

            const titleEl = document.createElement('div');
            titleEl.classList.add('node-title');
            titleEl.textContent = node.title || node.type;
            nodeEl.appendChild(titleEl);

            const contentEl = document.createElement('div');
            contentEl.classList.add('node-content');
            nodeEl.appendChild(contentEl);
            
            renderNodeSpecificContent(node, contentEl, nodeEl); 

            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('node-port') || e.target.closest('input, textarea, select, button')) {
                    return; 
                }
                e.preventDefault();
                e.stopPropagation();
                selectNode(node.id); 
                selectedElement = nodeEl;
                
                const graphCanvasRect = graphCanvas.getBoundingClientRect();
                const worldMouseX = (e.clientX - graphCanvasRect.left - panX) / currentZoom;
                const worldMouseY = (e.clientY - graphCanvasRect.top - panY) / currentZoom;

                offset.x = worldMouseX - node.x;
                offset.y = worldMouseY - node.y;
                
                nodeEl.style.cursor = 'grabbing';
            });
            
            worldContainer.appendChild(nodeEl); 
            return nodeEl;
        }

        function addPortLabel(portEl, labelText, type) {
            const labelEl = document.createElement('div');
            const typeClasses = type.split(' ').filter(Boolean); 
            labelEl.classList.add('port-label', ...typeClasses); 
            labelEl.textContent = labelText;
            labelEl.style.top = portEl.style.top; 
            const nodeContent = portEl.closest('.node')?.querySelector('.node-content');
            if (nodeContent) {
                 nodeContent.appendChild(labelEl); 
            } else {
                console.warn("Could not find node-content to append port label for port on node:", portEl.dataset.nodeId);
            }
        }
        
        function renderNodeSpecificContent(node, contentEl, nodeEl) {
            contentEl.innerHTML = ''; 

            const createLabel = (text) => {
                const label = document.createElement('label');
                label.textContent = text;
                return label;
            };
            const createInput = (type, value, placeholder, onChange) => {
                const input = document.createElement(type === 'textarea' ? 'textarea' : 'input');
                if (type !== 'textarea') input.type = type;
                input.value = value || '';
                if (placeholder) input.placeholder = placeholder;
                input.addEventListener('input', (e) => {
                    onChange(e.target.value); 
                    attemptSaveToCookies(); 
                });
                if (type === 'textarea') input.rows = 3;
                return input;
            };
             const createSelect = (options, selectedValue, onChange) => {
                const select = document.createElement('select');
                options.forEach(opt => {
                    const optionEl = document.createElement('option'); 
                    optionEl.value = typeof opt === 'string' ? opt : opt.value;
                    optionEl.textContent = typeof opt === 'string' ? opt : opt.text;
                    if ((typeof opt === 'string' ? opt : opt.value) === selectedValue) {
                        optionEl.selected = true;
                    }
                    select.appendChild(optionEl);
                });
                select.addEventListener('change', (e) => {
                    onChange(e.target.value);
                    attemptSaveToCookies();
                });
                return select;
            };
            
            nodeEl.querySelectorAll('.node-port').forEach(p => p.remove()); 
            contentEl.querySelectorAll('.port-label').forEach(l => l.remove());


            if (node.type === 'Scene') {
                const narrativeOutPort = createPort(node.id, 'output', 'narrative-out', 0); 
                nodeEl.appendChild(narrativeOutPort);
                addPortLabel(narrativeOutPort, "Narrative Out", "output");
                updateSceneCharacterPorts(node, nodeEl); 
            } else if (node.type === 'Character') {
                contentEl.appendChild(createLabel('Name:'));
                contentEl.appendChild(createInput('text', node.properties.name, 'Character Name', (val) => {
                    node.properties.name = val;
                    updateAllCharacterDependentNodes(); 
                }));
                contentEl.appendChild(createLabel('Replace Key:'));
                contentEl.appendChild(createInput('text', node.properties.replaceKey, '_CHARACTER_A', val => node.properties.replaceKey = val));
                const charOutputPort = createPort(node.id, 'output', 'char-out', 0); 
                nodeEl.appendChild(charOutputPort);
            } else if (node.type === 'Dialogue' || node.type === 'Interact' || node.type === 'Directive') {
                const generalInputPortCommon = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortCommon);
                const characters = nodes.filter(n => n.type === 'Character').map(n => ({ value: n.id, text: n.properties.name || n.id }));

                if (node.type === 'Dialogue') {
                    contentEl.appendChild(createLabel('Character:'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val));
                    contentEl.appendChild(createLabel('Dialogue Text:'));
                    contentEl.appendChild(createInput('textarea', node.properties.text, 'Character says...', val => node.properties.text = val));
                } else if (node.type === 'Interact') {
                    contentEl.appendChild(createLabel('Character (Prompter):'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val));
                    contentEl.appendChild(createLabel('Prompt Text (use \\ansX or \\monX):'));
                    contentEl.appendChild(createInput('textarea', node.properties.promptText, 'e.g., What is your \\ans10 name?', val => node.properties.promptText = val));
                    contentEl.appendChild(createLabel('Placeholder:'));
                    contentEl.appendChild(createInput('text', node.properties.placeholder, 'e.g., adjective', val => node.properties.placeholder = val));
                } else { // Directive
                    contentEl.appendChild(createLabel('Character (Actor):'));
                    contentEl.appendChild(createSelect(characters, node.properties.characterId, val => node.properties.characterId = val));
                    contentEl.appendChild(createLabel('Prompt/Situation:'));
                    contentEl.appendChild(createInput('textarea', node.properties.promptText, 'Situation leading to choice', val => node.properties.promptText = val));
                }
                
                if (node.type === 'Dialogue' || node.type === 'Interact') {
                    const advancedToggle = document.createElement('button');
                    advancedToggle.textContent = contentEl.classList.contains('expanded') ? 'Advanced Options ▲' : 'Advanced Options ▼';
                    advancedToggle.classList.add('text-sm', 'text-blue-600', 'dark:text-blue-400', 'mt-2', 'w-full', 'text-left');
                    const advancedContent = document.createElement('div');
                    advancedContent.classList.add('expandable-content', 'mt-2', 'border-t', 'pt-2');
                    if (contentEl.classList.contains('expanded')) advancedContent.style.maxHeight = '500px';

                    advancedContent.appendChild(createLabel('Pose:'));
                    advancedContent.appendChild(createInput('text', node.properties.pose, 'e.g., happy', val => node.properties.pose = val));
                    advancedContent.appendChild(createLabel('Expression:'));
                    advancedContent.appendChild(createInput('text', node.properties.expression, 'e.g., smiling', val => node.properties.expression = val));
                    advancedContent.appendChild(createLabel('Overlays:'));
                    advancedContent.appendChild(createInput('text', node.properties.overlays, 'e.g., blush', val => node.properties.overlays = val));
                    
                    contentEl.appendChild(advancedToggle);
                    contentEl.appendChild(advancedContent);
                    advancedToggle.onclick = () => {
                        contentEl.classList.toggle('expanded');
                        advancedToggle.textContent = contentEl.classList.contains('expanded') ? 'Advanced Options ▲' : 'Advanced Options ▼';
                    };
                }
                
                if (node.type !== 'Directive') { 
                    const generalOutputPortCommon = createPort(node.id, 'output', 'general-output', 0);
                    nodeEl.appendChild(generalOutputPortCommon);
                } else { 
                    const decisionsContainer = document.createElement('div'); 
                    if (!contentEl.contains(decisionsContainer)) contentEl.appendChild(decisionsContainer);


                    const renderDecisions = () => {
                        decisionsContainer.innerHTML = '';
                        nodeEl.querySelectorAll('.node-port.output-decision').forEach(p => p.remove());
                        // No need to remove labels here as they are not created for directive options

                        node.properties.options.forEach((opt, index) => {
                            const decisionDiv = document.createElement('div');
                            decisionDiv.classList.add('border', 'p-2', 'rounded', 'mb-2', 'relative');
                            decisionDiv.appendChild(createLabel(`Option ${index + 1} Summary:`));
                            const summaryInput = createInput('text', opt.summary, 'Summary', val => opt.summary = val);
                            decisionDiv.appendChild(summaryInput);
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.textContent = 'Remove';
                            removeBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'text-xs', 'absolute', 'top-1', 'right-1', 'p-1');
                            removeBtn.onclick = () => {
                                node.properties.options.splice(index, 1);
                                wires = wires.filter(w => !(w.fromNode === node.id && w.fromPort === `option-${opt.id}`));
                                renderDecisions(); 
                                redrawWires();
                                attemptSaveToCookies();
                            };
                            decisionDiv.appendChild(removeBtn);
                            decisionsContainer.appendChild(decisionDiv);

                            const portId = `option-${opt.id}`;
                            const optionPort = createPort(node.id, 'output-decision', portId, 0); // Index 0 as top is custom
                            
                            requestAnimationFrame(() => { 
                                let portTop = PORT_BASE_TOP_OFFSET + index * (PORT_SPACING + 20); // Default
                                if (summaryInput.offsetParent && decisionDiv.offsetParent) {
                                     portTop = decisionDiv.offsetTop + summaryInput.offsetTop + (summaryInput.offsetHeight / 2) - (optionPort.offsetHeight / 2);
                                }
                                optionPort.style.top = `${portTop}px`;
                            });
                            nodeEl.appendChild(optionPort);
                        });
                    };

                    const addDecisionBtn = document.createElement('button');
                    addDecisionBtn.textContent = 'Add Decision';
                    addDecisionBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'w-full', 'mt-2');
                    addDecisionBtn.onclick = () => {
                        const newOptionId = generateId();
                        node.properties.options.push({ id: newOptionId, summary: ''}); 
                        renderDecisions(); 
                        attemptSaveToCookies();
                    };
                    contentEl.appendChild(addDecisionBtn); 
                    renderDecisions();
                }


            } else if (node.type === 'Weather' || node.type === 'Time') {
                const generalInputPortWT = createPort(node.id, 'input', 'general-input', 0);
                nodeEl.appendChild(generalInputPortWT);

                contentEl.appendChild(createLabel(node.type === 'Weather' ? 'Condition:' : 'Time (HH:00):'));
                contentEl.appendChild(createInput('text', 
                    node.type === 'Weather' ? node.properties.condition : node.properties.time, 
                    node.type === 'Weather' ? 'e.g., Clear, Rainy' : 'e.g., 08:00, 17:00', 
                    val => {
                        if (node.type === 'Weather') node.properties.condition = val;
                        else node.properties.time = val;
                    }
                ));
                const generalOutputPortWT = createPort(node.id, 'output', 'general-output', 0);
                nodeEl.appendChild(generalOutputPortWT);
            }
        }

        function updateSceneCharacterPorts(sceneNode, sceneNodeEl) {
            sceneNodeEl.querySelectorAll('.node-port.input[data-port-type="character-input"]').forEach(p => p.remove());
            const contentEl = sceneNodeEl.querySelector('.node-content');
            if (contentEl) {
                 contentEl.querySelectorAll('.port-label.input.character-input-label').forEach(l => l.remove());
            }

            const connectedCharWires = wires.filter(w => w.toNode === sceneNode.id && w.toPort.startsWith('char-in-'));
            const numChars = connectedCharWires.length;
            let charPortIndex = 0; 

            for (let i = 0; i < numChars + 1; i++) {
                const portId = `char-in-${i}`;
                const port = createPort(sceneNode.id, 'input', portId, charPortIndex++, 'character-input'); 
                sceneNodeEl.appendChild(port);
                addPortLabel(port, `Char In ${i+1}`, "input character-input-label"); 
            }
            const minHeightBase = 60; 
            const sceneContentEl = sceneNodeEl.querySelector('.node-content');
            if(sceneContentEl) {
                 sceneNodeEl.style.minHeight = `${minHeightBase + (numChars + 1) * PORT_SPACING + PORT_BASE_TOP_OFFSET}px`;
            }

            updateAllCharacterDependentNodes(); 
        }

        function createPort(nodeId, type, portId, index, portType = 'general') {
            const port = document.createElement('div');
            port.classList.add('node-port', type);
            if (type === 'output-decision') port.classList.add('output');
            port.dataset.nodeId = nodeId;
            port.dataset.portId = portId;
            port.dataset.portType = portType; 
            
            if (type !== 'output-decision' || portType === 'general') { 
                 port.style.top = `${PORT_BASE_TOP_OFFSET + index * PORT_SPACING}px`;
            }


            port.addEventListener('mousedown', (e) => {
                e.stopPropagation(); 
                isWiring = true;
                startPort = port;
                tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tempWire.classList.add('temp-wire');
                wiresSvg.appendChild(tempWire); 
                document.body.style.cursor = 'crosshair';
            });
            port.addEventListener('mouseup', (e) => {
                if (isWiring && startPort && startPort !== port) {
                    const fromNodeId = startPort.dataset.nodeId;
                    const fromPortId = startPort.dataset.portId;
                    const toNodeId = port.dataset.nodeId;
                    const toPortId = port.dataset.portId;

                    const startNode = findNodeById(fromNodeId);
                    const endNode = findNodeById(toNodeId);
                    const startPortClassType = startPort.classList.contains('input') ? 'input' : 'output';
                    const endPortClassType = port.classList.contains('input') ? 'input' : 'output';

                    let canConnect = true;
                    if (!startNode || !endNode || fromNodeId === toNodeId || startPortClassType === endPortClassType) {
                        canConnect = false;
                    } else if (endNode.type === 'Scene') { 
                        if (startNode.type === 'Character' && port.dataset.portType === 'character-input') {
                            // Allow Character -> Scene (Char In X)
                        } else {
                            canConnect = false;
                        }
                    } else if (startNode.type === 'Scene') { 
                        if (fromPortId === 'narrative-out' && port.dataset.portId === 'general-input') { 
                            // Allow Scene (Narrative Out) -> Other Node (General In)
                        } else {
                            canConnect = false; 
                        }
                    } else if (startNode.type === 'Character') {
                        if(endNode.type !== 'Scene' || port.dataset.portType !== 'character-input') {
                            canConnect = false;
                        }
                    }
                    // Weather and Time now behave like general nodes with input/output, handled by default


                    if (canConnect) {
                        const existingWireToPort = wires.find(w => w.toNode === toNodeId && w.toPort === toPortId);
                        if (existingWireToPort && endPortClassType === 'input') {
                            wires = wires.filter(w => w.id !== existingWireToPort.id);
                        }
                        // Enforce single outgoing wire for Scene's narrative-out and Character's char-out
                        if ((startNode.type === 'Scene' && fromPortId === 'narrative-out') || 
                            (startNode.type === 'Character' && fromPortId === 'char-out')) {
                            const existingOutgoingWire = wires.find(w => w.fromNode === fromNodeId && w.fromPort === fromPortId);
                            if (existingOutgoingWire) {
                                wires = wires.filter(w => w.id !== existingOutgoingWire.id);
                            }
                        }


                        const newWire = {
                            id: generateId(),
                            fromNode: fromNodeId,
                            fromPort: fromPortId,
                            toNode: toNodeId,
                            toPort: toPortId,
                            color: wireColors[nextWireColorIndex % wireColors.length]
                        };
                        wires.push(newWire);
                        nextWireColorIndex++;
                        redrawWires();
                        attemptSaveToCookies();

                        if (endNode.type === 'Scene' && startNode.type === 'Character') {
                            updateSceneCharacterPorts(endNode, document.getElementById(endNode.id));
                        }
                    }
                }
                stopWiring();
            });
            port.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const pNodeId = port.dataset.nodeId;
                const pPortId = port.dataset.portId;
                
                const initialWireCount = wires.length;
                wires = wires.filter(w => 
                    !( (w.fromNode === pNodeId && w.fromPort === pPortId) ||
                       (w.toNode === pNodeId && w.toPort === pPortId) )
                );

                if (wires.length < initialWireCount) { 
                    const sceneNode = findNodeById(pNodeId);
                    if (sceneNode && sceneNode.type === 'Scene' && port.dataset.portType === 'character-input') {
                        updateSceneCharacterPorts(sceneNode, document.getElementById(pNodeId));
                    }
                    redrawWires();
                    attemptSaveToCookies();
                }
            });
            return port;
        }
        
        function addNodeToGraph(type, x, y, properties = {}) { 
            const baseProps = {
                Scene: { title: 'Scene' },
                Character: { title: 'Character', name: 'New Character', replaceKey: '_NEW_CHAR' },
                Dialogue: { title: 'Dialogue', characterId: null, text: '', pose: '', expression: '', overlays: '' },
                Interact: { title: 'Interact', characterId: null, promptText: '', placeholder: '', pose: '', expression: '', overlays: '' }, 
                Directive: { title: 'Directive', characterId: null, promptText: '', options: [] },
                Weather: { title: 'Weather', condition: 'Clear' },
                Time: { title: 'Time', time: '12:00' }
            };

            const newNode = {
                id: generateId(),
                type: type,
                x: x, 
                y: y,
                properties: { ...baseProps[type], ...properties },
                zIndex: highestZIndex++ 
            };
            nodes.push(newNode);
            const nodeEl = createNodeElement(newNode); 
            if (type === 'Character') {
                updateAllCharacterDependentNodes();
            }
            attemptSaveToCookies();
            return newNode;
        }

        function selectNode(nodeId) {
            if (selectedNodeId && selectedNodeId !== nodeId) {
                document.getElementById(selectedNodeId)?.classList.remove('selected');
            }
            if (nodeId) {
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    const node = findNodeById(nodeId);
                    if (node) {
                        node.zIndex = highestZIndex++;
                        nodeEl.style.zIndex = node.zIndex;
                    }
                }
                selectedNodeId = nodeId;
            } else {
                selectedNodeId = null;
            }
        }

        function deleteSelectedNode() {
            if (!selectedNodeId) return;
            const nodeToRemove = findNodeById(selectedNodeId);
            const nodeEl = document.getElementById(selectedNodeId);
            if (nodeEl) nodeEl.remove();
            
            nodes = nodes.filter(n => n.id !== selectedNodeId);
            wires = wires.filter(w => w.fromNode !== selectedNodeId && w.toNode !== selectedNodeId);
            
            if (nodeToRemove) {
                if (nodeToRemove.type === 'Character') {
                    nodes.filter(n => n.type === 'Scene').forEach(sceneNode => {
                        const sceneEl = document.getElementById(sceneNode.id);
                        if (sceneEl) updateSceneCharacterPorts(sceneNode, sceneEl);
                    });
                    updateAllCharacterDependentNodes(); 
                }
            }

            redrawWires();
            selectedNodeId = null;
            attemptSaveToCookies();
        }
        
        function findNodeById(id) {
            return nodes.find(n => n.id === id);
        }

        function updateAllCharacterDependentNodes() {
            nodes.forEach(node => {
                if (['Dialogue', 'Interact', 'Directive'].includes(node.type)) { 
                    const nodeEl = document.getElementById(node.id);
                    const contentEl = nodeEl?.querySelector('.node-content');
                    if (nodeEl && contentEl) {
                        const isExpanded = contentEl.classList.contains('expanded');
                        renderNodeSpecificContent(node, contentEl, nodeEl);
                        if (isExpanded && (node.type === 'Dialogue' || node.type === 'Interact')) { 
                             contentEl.classList.add('expanded');
                        }
                    }
                }
            });
        }


        // --- Wiring Management ---
        function redrawWires() {
            wiresSvg.innerHTML = ''; 
            const graphCanvasRect = graphCanvas.getBoundingClientRect(); 
            
            wires.forEach(wire => {
                const fromNodeEl = document.getElementById(wire.fromNode);
                const toNodeEl = document.getElementById(wire.toNode);
                if (!fromNodeEl || !toNodeEl) {
                    wires = wires.filter(w => w.id !== wire.id); 
                    return;
                }

                const fromPortEl = fromNodeEl.querySelector(`.node-port[data-port-id="${wire.fromPort}"]`);
                const toPortEl = toNodeEl.querySelector(`.node-port[data-port-id="${wire.toPort}"]`);

                if (!fromPortEl || !toPortEl) {
                     wires = wires.filter(w => w.id !== wire.id); 
                    return;
                }

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                const fromPortRect = fromPortEl.getBoundingClientRect();
                const toPortRect = toPortEl.getBoundingClientRect();

                const x1_world = (fromPortRect.left + fromPortRect.width / 2 - graphCanvasRect.left - panX) / currentZoom;
                const y1_world = (fromPortRect.top + fromPortRect.height / 2 - graphCanvasRect.top - panY) / currentZoom;
                const x2_world = (toPortRect.left + toPortRect.width / 2 - graphCanvasRect.left - panX) / currentZoom;
                const y2_world = (toPortRect.top + toPortRect.height / 2 - graphCanvasRect.top - panY) / currentZoom;
                
                const dx = Math.abs(x1_world - x2_world) * 0.5;
                const d = `M ${x1_world} ${y1_world} C ${x1_world + dx} ${y1_world}, ${x2_world - dx} ${y2_world}, ${x2_world} ${y2_world}`;
                
                line.setAttribute('d', d);
                line.classList.add('wire');
                line.style.stroke = wire.color || '#6b7280';
                wiresSvg.appendChild(line);
            });
        }

        function stopWiring() {
            isWiring = false;
            startPort = null;
            if (tempWire) {
                tempWire.remove();
                tempWire = null;
            }
            document.body.style.cursor = 'default';
        }

        // --- Canvas Interaction (Pan & Zoom) ---
        graphCanvas.addEventListener('mousedown', (e) => {
            if (e.target === graphCanvas || e.target === worldContainer) { 
                isPanning = true;
                lastPanPosition = { x: e.clientX, y: e.clientY };
                graphCanvas.style.cursor = 'grabbing';
                selectNode(null); 
                hideContextMenu();
            }
        });

        document.addEventListener('mousemove', (e) => {
            lastMouseScreenX = e.clientX; 
            lastMouseScreenY = e.clientY;

            if (selectedElement && !isWiring) { 
                e.preventDefault();
                const graphCanvasRect = graphCanvas.getBoundingClientRect();
                const mouseViewportX = e.clientX - graphCanvasRect.left;
                const mouseViewportY = e.clientY - graphCanvasRect.top;

                const newWorldX = (mouseViewportX - panX) / currentZoom - offset.x;
                const newWorldY = (mouseViewportY - panY) / currentZoom - offset.y;

                const node = findNodeById(selectedElement.id);
                if (node) {
                    node.x = newWorldX;
                    node.y = newWorldY;
                }
                selectedElement.style.left = `${newWorldX}px`;
                selectedElement.style.top = `${newWorldY}px`;
                redrawWires();
            } else if (isPanning) {
                e.preventDefault();
                const dx = e.clientX - lastPanPosition.x;
                const dy = e.clientY - lastPanPosition.y;
                panX += dx;
                panY += dy;
                lastPanPosition = { x: e.clientX, y: e.clientY };
                updateWorldTransform(); 
                 redrawWires(); 
            } else if (isWiring && tempWire && startPort) {
                e.preventDefault();
                const fromPortRect = startPort.getBoundingClientRect(); 
                const graphCanvasRect = graphCanvas.getBoundingClientRect();
                
                const x1_world = (fromPortRect.left + fromPortRect.width / 2 - graphCanvasRect.left - panX) / currentZoom;
                const y1_world = (fromPortRect.top + fromPortRect.height / 2 - graphCanvasRect.top - panY) / currentZoom;
                
                const mouseWorldCoords = getGraphCoordinates(e.clientX, e.clientY); 
                const x2_world = mouseWorldCoords.x;
                const y2_world = mouseWorldCoords.y;

                tempWire.setAttribute('x1', x1_world);
                tempWire.setAttribute('y1', y1_world);
                tempWire.setAttribute('x2', x2_world);
                tempWire.setAttribute('y2', y2_world);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (selectedElement) {
                selectedElement.style.cursor = 'grab';
                selectedElement = null;
                attemptSaveToCookies(); 
            }
            if (isPanning) {
                isPanning = false;
                graphCanvas.style.cursor = 'grab';
            }
            if (isWiring) {
                if (!e.target.classList.contains('node-port')) {
                     stopWiring();
                }
            }
        });

        graphCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.05; 
            const oldZoom = currentZoom;
            
            const graphCanvasRect = graphCanvas.getBoundingClientRect();
            const mouseXInViewport = e.clientX - graphCanvasRect.left; 
            const mouseYInViewport = e.clientY - graphCanvasRect.top; 

            const mouseWorldXBeforeZoom = (mouseXInViewport - panX) / oldZoom;
            const mouseWorldYBeforeZoom = (mouseYInViewport - panY) / oldZoom;

            if (e.deltaY < 0) { 
                currentZoom = Math.min(currentZoom + zoomSpeed * currentZoom, 3); 
            } else { 
                currentZoom = Math.max(currentZoom - zoomSpeed * currentZoom, 0.1); 
            }
            
            panX = mouseXInViewport - mouseWorldXBeforeZoom * currentZoom;
            panY = mouseYInViewport - mouseWorldYBeforeZoom * currentZoom;
            
            updateWorldTransform(); 
            redrawWires(); 
        }, { passive: false });


        // --- Left Panel Node Drag & Drop ---
        function initializeLeftPanel() {
            NODE_TYPES.forEach(type => {
                const el = document.createElement('div');
                el.classList.add('panel-node-type');
                el.textContent = type;
                el.draggable = true;
                el.dataset.nodeType = type;
                el.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', type);
                    e.dataTransfer.effectAllowed = 'copy';
                });
                leftPanel.appendChild(el);
            });
        }

        graphCanvas.addEventListener('dragover', (e) => {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'copy';
        });

        graphCanvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('text/plain');
            if (NODE_TYPES.includes(nodeType)) {
                const worldCoords = getGraphCoordinates(e.clientX, e.clientY);
                addNodeToGraph(nodeType, worldCoords.x, worldCoords.y);
            }
        });


        // --- Context Menu ---
        let contextMenuTargetNodeId = null;
        
        function showContextMenu(menuItems, screenX, screenY) {
            contextMenu.innerHTML = '';
            menuItems.forEach(item => {
                const menuItemEl = document.createElement('div');
                menuItemEl.classList.add('context-menu-item');
                menuItemEl.textContent = item.label;
                menuItemEl.addEventListener('click', () => {
                    item.action();
                    hideContextMenu();
                });
                contextMenu.appendChild(menuItemEl);
            });
            contextMenu.style.left = `${screenX}px`;
            contextMenu.style.top = `${screenY}px`;
            contextMenu.classList.remove('hidden');
        }

        function populateAndShowAddNodeMenu(worldX, worldY, screenX, screenY) {
            const addNodeMenuItems = NODE_TYPES.map(type => ({
                label: `Add ${type} Node`,
                action: () => addNodeToGraph(type, worldX, worldY)
            }));
            showContextMenu(addNodeMenuItems, screenX, screenY);
        }


        graphCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            hideContextMenu(); 

            const targetNodeEl = e.target.closest('.node');
            const worldCoords = getGraphCoordinates(e.clientX, e.clientY); 

            let menuItems = [];

            if (targetNodeEl) {
                contextMenuTargetNodeId = targetNodeEl.id;
                selectNode(contextMenuTargetNodeId); 
                menuItems.push({ label: 'Delete Node', action: () => deleteSelectedNode() });
                menuItems.push({ label: 'Duplicate Node', action: () => duplicateNode(contextMenuTargetNodeId) });
                if (findNodeById(contextMenuTargetNodeId)?.type !== 'Scene') { 
                     menuItems.push({ label: 'Read Story Up To Here', action: () => displayStoryToNode(contextMenuTargetNodeId) });
                }
                showContextMenu(menuItems, e.clientX, e.clientY);
            } else {
                contextMenuTargetNodeId = null;
                populateAndShowAddNodeMenu(worldCoords.x, worldCoords.y, e.clientX, e.clientY);
            }
        });

        function hideContextMenu() {
            contextMenu.classList.add('hidden');
            contextMenuTargetNodeId = null;
        }
        
        function duplicateNode(nodeId) {
            const originalNode = findNodeById(nodeId);
            if (!originalNode) return;
            const newNodeProps = JSON.parse(JSON.stringify(originalNode.properties)); 
            addNodeToGraph(originalNode.type, originalNode.x + 20 / currentZoom, originalNode.y + 20 / currentZoom, newNodeProps);
        }


        // --- Keyboard Shortcuts ---
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault(); 
                if (alwaysDownloadOnSave) {
                    showToast("Downloading graph as JSON file...");
                    downloadGraphAsJson();
                } else {
                    const saveResult = attemptSaveToCookies();
                    if (saveResult === 'saved_single') {
                        showToast("Graph saved to cookies!");
                    } else if (saveResult === 'saved_sliced') {
                        const numSlices = parseInt(getCookie('storyGraphData_slices') || '0', 10);
                        showToast(`Graph saved in ${numSlices} cookie(s) due to size.`);
                    } else if (saveResult === 'save_failed_too_large') {
                        showToast("Graph too large for cookies. Downloading as JSON file instead.");
                        downloadGraphAsJson();
                    }
                }
                return; 
            }
            
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return; 
            }

            if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelectedNode();
            }
            if (e.key === 'Escape') {
                settingsPanel.classList.toggle('open');
                readStoryModal.classList.add('hidden'); 
                hideContextMenu();
                selectNode(null); 
            }
            if (e.shiftKey && (e.key === 'A' || e.key === 'a')) {
                e.preventDefault();
                const worldCoords = getGraphCoordinates(lastMouseScreenX, lastMouseScreenY);
                populateAndShowAddNodeMenu(worldCoords.x, worldCoords.y, lastMouseScreenX, lastMouseScreenY);
            }
        });

        // --- Startup Modal & Cookie Logic ---
        function checkSavedGraph() {
            const savedGraphJSON = getCookie('storyGraphData_slices'); 
            if (savedGraphJSON || getCookie('storyGraphData_0')) { 
                openSavedStoryBtn.classList.remove('hidden');
            } else {
                openSavedStoryBtn.classList.add('hidden');
            }
        }

        newStoryBtn.addEventListener('click', () => {
            clearGraph();
            addNodeToGraph('Scene', 50, 50); 
            startupModal.classList.add('hidden');
        });

        openSavedStoryBtn.addEventListener('click', () => {
            loadGraphFromCookies();
            startupModal.classList.add('hidden');
        });

        // --- Save & Load ---
        function attemptSaveToCookies() { 
            if (alwaysDownloadOnSave && (event && (event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's')) {
                return 'download_preferred';
            }

            const graphData = {
                nodes: nodes,
                wires: wires,
                panX: panX,
                panY: panY,
                currentZoom: currentZoom,
                darkMode: document.body.classList.contains('dark'),
                highestZIndex: highestZIndex,
                storyTitle: storyTitle,
                storyAuthor: storyAuthor,
                storyTags: storyTags,
                alwaysDownloadOnSave: alwaysDownloadOnSave
            };
            try {
                const jsonString = JSON.stringify(graphData);
                const encodedJsonString = encodeURIComponent(jsonString);

                if (encodedJsonString.length <= COOKIE_SLICE_MAX_LENGTH) {
                    deleteCookiesByPrefix('storyGraphData_'); 
                    deleteCookie('storyGraphData_slices');
                    setCookie('storyGraphData_0', encodedJsonString, 7);
                    setCookie('storyGraphData_slices', '1', 7);
                    return 'saved_single';
                } else {
                    const numSlices = Math.ceil(encodedJsonString.length / COOKIE_SLICE_MAX_LENGTH);
                    if (numSlices > MAX_COOKIE_SLICES) {
                        console.warn(`Graph data too large for even ${MAX_COOKIE_SLICES} cookie slices. Ctrl+S will download.`);
                        return 'save_failed_too_large'; 
                    }

                    deleteCookie('storyGraphData'); 
                    deleteCookiesByPrefix('storyGraphData_'); 

                    for (let i = 0; i < numSlices; i++) {
                        const slice = encodedJsonString.substring(i * COOKIE_SLICE_MAX_LENGTH, (i + 1) * COOKIE_SLICE_MAX_LENGTH);
                        setCookie(`storyGraphData_${i}`, slice, 7);
                    }
                    setCookie('storyGraphData_slices', numSlices.toString(), 7);
                    return 'saved_sliced';
                }
            } catch (error) {
                console.error("Error saving graph to cookies:", error);
                return 'error'; 
            }
        }
        
        function downloadGraphAsJson() {
            const graphData = { nodes, wires, panX, panY, currentZoom, darkMode: document.body.classList.contains('dark'), highestZIndex, storyTitle, storyAuthor, storyTags, alwaysDownloadOnSave };
            const jsonString = JSON.stringify(graphData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'story_graph_editor_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }


        function loadGraphFromData(graphData) {
            clearGraph(); 
            nodes = graphData.nodes || [];
            wires = graphData.wires || [];
            panX = graphData.panX || 0;
            panY = graphData.panY || 0;
            currentZoom = graphData.currentZoom || 1;
            highestZIndex = graphData.highestZIndex || (nodes.length +1);
            storyTitle = graphData.storyTitle || "My Awesome Story";
            storyAuthor = graphData.storyAuthor || "";
            storyTags = graphData.storyTags || "";
            alwaysDownloadOnSave = graphData.alwaysDownloadOnSave || false;


            storyTitleInput.value = storyTitle;
            storyAuthorInput.value = storyAuthor;
            storyTagsInput.value = storyTags;
            alwaysDownloadToggle.checked = alwaysDownloadOnSave;


            if (graphData.darkMode) {
                document.body.classList.add('dark');
                darkModeToggle.checked = true;
            } else {
                document.body.classList.remove('dark');
                darkModeToggle.checked = false;
            }
            
            const dot = darkModeToggle.parentElement.querySelector('.dot');
            if (darkModeToggle.checked) { dot.style.transform = 'translateX(100%)'; } 
            else { dot.style.transform = 'translateX(0%)'; }
            
            const alwaysDownloadDot = alwaysDownloadToggle.closest('label').querySelector('.dot'); 
             if (alwaysDownloadToggle.checked) { alwaysDownloadDot.style.transform = 'translateX(100%)'; } 
            else { alwaysDownloadDot.style.transform = 'translateX(0%)'; }
            
            updateWorldTransform(); 

            nodes.forEach(node => {
                node.zIndex = node.zIndex || highestZIndex++; 
                const el = createNodeElement(node); 
            });
            redrawWires();
        }
        
        function loadGraphFromCookies() {
            let fullEncodedJsonString = "";
            const numSlicesStr = getCookie('storyGraphData_slices');
            
            if (numSlicesStr) {
                const numSlices = parseInt(numSlicesStr, 10);
                if (!isNaN(numSlices) && numSlices > 0) {
                    for (let i = 0; i < numSlices; i++) {
                        const slice = getCookie(`storyGraphData_${i}`);
                        if (slice) {
                            fullEncodedJsonString += slice;
                        } else {
                            console.error(`Missing cookie slice: storyGraphData_${i}`);
                            fullEncodedJsonString = ""; 
                            break;
                        }
                    }
                }
            } else {
                const oldCookieData = getCookie('storyGraphData'); 
                if (oldCookieData) { 
                    fullEncodedJsonString = oldCookieData; 
                } else { 
                     fullEncodedJsonString = getCookie('storyGraphData_0') || "";
                }
            }

            if (fullEncodedJsonString) {
                try {
                    const decodedJsonString = decodeURIComponent(fullEncodedJsonString);
                    const graphData = JSON.parse(decodedJsonString);
                    loadGraphFromData(graphData);
                } catch (error) {
                    console.error("Error parsing saved graph from cookies:", error);
                    alert("Could not load saved story. Data might be corrupted.");
                    clearGraph(); 
                }
            } else if (numSlicesStr && parseInt(numSlicesStr,10) > 0) { 
                 alert("Could not load saved story. Cookie data seems incomplete.");
                 clearGraph();
            }
        }

        function clearGraph() {
            nodes = [];
            wires = [];
            worldContainer.querySelectorAll('.node').forEach(n => n.remove()); 
            wiresSvg.innerHTML = '';
            selectedNodeId = null;
            panX = 0;
            panY = 0;
            currentZoom = 1;
            highestZIndex = 1;
            storyTitle = "My Awesome Story";
            storyAuthor = "";
            storyTags = "";
            alwaysDownloadOnSave = false; 
            storyTitleInput.value = storyTitle;
            storyAuthorInput.value = storyAuthor;
            storyTagsInput.value = storyTags;
            alwaysDownloadToggle.checked = alwaysDownloadOnSave;
            
            deleteCookie('storyGraphData_slices');
            deleteCookie('storyGraphData'); 
            for (let i = 0; i < MAX_COOKIE_SLICES; i++) { 
                deleteCookie(`storyGraphData_${i}`);
            }

            updateWorldTransform(); 
            redrawWires();
        }

        function deleteCookie(name) {
            document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT; SameSite=Lax';
        }
        function deleteCookiesByPrefix(prefix) {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i];
                const eqPos = cookie.indexOf("=");
                const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
                if (name.startsWith(prefix)) {
                    deleteCookie(name);
                }
            }
        }


        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length); 
            }
            return null;
        }

        // --- Settings Panel Logic ---
        storyTitleInput.addEventListener('input', (e) => {
            storyTitle = e.target.value;
            attemptSaveToCookies();
        });
        storyAuthorInput.addEventListener('input', (e) => {
            storyAuthor = e.target.value;
            attemptSaveToCookies();
        });
        storyTagsInput.addEventListener('input', (e) => {
            storyTags = e.target.value;
            attemptSaveToCookies();
        });
        alwaysDownloadToggle.addEventListener('change', (e) => {
            alwaysDownloadOnSave = e.target.checked;
            const dot = e.target.closest('label').querySelector('.dot'); 
            if (alwaysDownloadToggle.checked) { dot.style.transform = 'translateX(100%)'; }
            else { dot.style.transform = 'translateX(0%)'; }
            attemptSaveToCookies(); 
        });


        darkModeToggle.addEventListener('change', () => {
            document.body.classList.toggle('dark');
            const dot = darkModeToggle.parentElement.querySelector('.dot');
            if (darkModeToggle.checked) {
                 dot.style.transform = 'translateX(100%)'; 
            } else {
                 dot.style.transform = 'translateX(0%)';
            }
            attemptSaveToCookies(); 
        });
        
        exportGraphJsonBtn.addEventListener('click', downloadGraphAsJson); 

        exportStoryNarrativeBtn.addEventListener('click', () => {
            const tagsArray = storyTags ? storyTags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

            const storyJSON = {
                title: storyTitle,
                author: storyAuthor || "Unknown Author",
                date: new Date().toISOString().split('T')[0],
                tags: tagsArray,
                content: {
                    scene: { location: "Default Location", time: "Noon", weather: "Clear" },
                    characters: [],
                    narrative: []
                }
            };

            const sceneNode = nodes.find(n => n.type === 'Scene');
            if (sceneNode) {
                storyJSON.content.scene.location = sceneNode.properties.location || "A Scene"; 
                
                const firstNarrativeNodeId = wires.find(w => w.fromNode === sceneNode.id && w.fromPort === 'narrative-out')?.toNode;
                let tempNode = findNodeById(firstNarrativeNodeId);
                let tempCounter = 0;
                while(tempNode && tempCounter < 5) { 
                    if (tempNode.type === 'Time' && storyJSON.content.scene.time === "Noon") { 
                        storyJSON.content.scene.time = tempNode.properties.time;
                    }
                    if (tempNode.type === 'Weather' && storyJSON.content.scene.weather === "Clear") {
                        storyJSON.content.scene.weather = tempNode.properties.condition;
                    }
                    const nextWire = wires.find(w => w.fromNode === tempNode.id && w.fromPort === 'general-output');
                    tempNode = nextWire ? findNodeById(nextWire.toNode) : null;
                    tempCounter++;
                }


                wires.filter(w => w.toNode === sceneNode.id && w.toPort.startsWith('char-in-')).forEach(charWire => {
                    const charNode = findNodeById(charWire.fromNode);
                    if (charNode && charNode.type === 'Character') {
                        storyJSON.content.characters.push({
                            replace: charNode.properties.replaceKey,
                            name: charNode.properties.name,
                            sex: "unknown", "hair-length": "unknown", "hair-color": "#000000",
                            "eye-color": "#000000", clothes: "unknown", controller: "unknown"
                        });
                    }
                });
            } else {
                alert("No Scene node found. Scene details will be default. Narrative export might be incomplete.");
            }
            
            let currentNarrativeNodeId = null;
            if (sceneNode) {
                 const sceneOutWire = wires.find(w => w.fromNode === sceneNode.id && w.fromPort === 'narrative-out');
                 if (sceneOutWire) currentNarrativeNodeId = sceneOutWire.toNode;
            }
            if (!currentNarrativeNodeId) { 
                currentNarrativeNodeId = nodes.find(n => ['Dialogue', 'Interact', 'Directive', 'Time', 'Weather'].includes(n.type) && !wires.some(w => w.toNode === n.id))?.id;
            }

            const narrativeVisited = new Set();
            let narrativeChainCounter = 0; 
            while (currentNarrativeNodeId && !narrativeVisited.has(currentNarrativeNodeId) && narrativeChainCounter < nodes.length * 2) {
                narrativeVisited.add(currentNarrativeNodeId);
                narrativeChainCounter++;
                const node = findNodeById(currentNarrativeNodeId);
                if (!node) break;

                let narrativeItem = { type: node.type.toLowerCase() };
                 if (node.type === 'Dialogue') {
                    const char = findNodeById(node.properties.characterId);
                    narrativeItem.character = char ? char.properties.replaceKey : "UNKNOWN_CHAR";
                    narrativeItem.text = node.properties.text;
                    if (node.properties.expression) narrativeItem.sprite = node.properties.expression;
                    if (node.properties.pose) narrativeItem.pose = node.properties.pose;
                    if (node.properties.overlays) narrativeItem.overlay = node.properties.overlays;
                    storyJSON.content.narrative.push(narrativeItem);
                } else if (node.type === 'Interact') {
                    narrativeItem.interaction = "short-answer"; 
                    narrativeItem.placeholder = node.properties.placeholder;
                    narrativeItem.text = node.properties.promptText;
                    if (node.properties.expression) narrativeItem.sprite = node.properties.expression;
                    if (node.properties.pose) narrativeItem.pose = node.properties.pose;
                    if (node.properties.overlays) narrativeItem.overlay = node.properties.overlays;
                    if (node.properties.characterId) { 
                        const char = findNodeById(node.properties.characterId);
                        narrativeItem.character = char ? char.properties.replaceKey : "UNKNOWN_CHAR";
                    }
                    storyJSON.content.narrative.push(narrativeItem);
                } else if (node.type === 'Directive') {
                     if (node.properties.characterId) { 
                        const char = findNodeById(node.properties.characterId);
                        narrativeItem.character = char ? char.properties.replaceKey : "UNKNOWN_CHAR";
                    }
                    narrativeItem.options = node.properties.options.map((opt, index) => {
                        const nextWire = wires.find(w => w.fromNode === node.id && w.fromPort === `option-${opt.id}`);
                        return {
                            summary: opt.summary,
                            text: opt.summary, 
                            [`i${storyJSON.content.narrative.filter(item => item.type === 'directive').length + 1}`]: index, 
                            next_node_id: nextWire ? nextWire.toNode : null 
                        };
                    });
                    storyJSON.content.narrative.push(narrativeItem);
                }
                
                let nextWire = wires.find(w => w.fromNode === currentNarrativeNodeId && w.fromPort === 'general-output');
                if (!nextWire && node.type === 'Directive' && node.properties.options.length > 0) {
                    nextWire = wires.find(w => w.fromNode === currentNarrativeNodeId && w.fromPort === `option-${node.properties.options[0].id}`);
                }
                currentNarrativeNodeId = nextWire ? nextWire.toNode : null;
            }

            const jsonString = JSON.stringify(storyJSON, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${storyTitle.toLowerCase().replace(/\s+/g, '_') || 'story'}_narrative.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });


        importJsonFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const graphData = JSON.parse(e.target.result);
                        loadGraphFromData(graphData);
                        attemptSaveToCookies(); 
                    } catch (error) {
                        console.error("Error importing JSON:", error);
                        alert("Failed to import JSON. File might be corrupted or not in the correct format.");
                    }
                };
                reader.readAsText(file);
                importJsonFile.value = ''; 
            }
        });

        // --- "Read Story Up To Node" Logic ---
        closeReadStoryModalBtn.addEventListener('click', () => readStoryModal.classList.add('hidden'));

        function displayStoryToNode(targetNodeId) {
            const paths = traceAllPathsToNode(targetNodeId);
            storyPathDisplay.innerHTML = ''; 

            if (paths.length === 0) {
                storyPathDisplay.innerHTML = '<p>No narrative path found to this node, or it is a starting node.</p>';
            } else {
                paths.forEach((path, index) => {
                    if (index > 0) storyPathDisplay.appendChild(document.createElement('hr'));
                    
                    const pathContainer = document.createElement('div');
                    const instructionsEl = document.createElement('p');
                    instructionsEl.innerHTML = `<strong>Path ${index + 1} Instructions:</strong> ${path.decisions.join(' &rarr; ') || 'Direct Path'}`;
                    pathContainer.appendChild(instructionsEl);

                    let narrativeText = "";
                    path.nodes.forEach(nodeId => {
                        const node = findNodeById(nodeId);
                        if (node) {
                            let charName = "Narrator"; 
                            if (node.properties.characterId) {
                                const charNode = findNodeById(node.properties.characterId);
                                if (charNode) {
                                    charName = charNode.properties.name || charNode.properties.replaceKey || "Character";
                                } else {
                                    charName = "Unknown Character";
                                }
                            }

                            if (node.type === 'Dialogue') {
                                narrativeText += `${charName}: "${node.properties.text}"\n\n`;
                            } else if (node.type === 'Interact') {
                                const interactor = node.properties.characterId ? charName : "(Interaction)";
                                narrativeText += `${interactor}: ${node.properties.promptText.replace(/\\ans\d+/g, '[INPUT]').replace(/\\mon\d+/g, '[LONG INPUT]')}\n\n`;
                            } else if (node.type === 'Directive') {
                                const director = node.properties.characterId ? charName : "(Decision Point)";
                                narrativeText += `${director}: ${node.properties.promptText || 'Choose an option...'}\n\n`;
                            }
                        }
                    });
                    const textEl = document.createElement('p');
                    textEl.textContent = narrativeText.trim();
                    pathContainer.appendChild(textEl);
                    storyPathDisplay.appendChild(pathContainer);
                });
            }
            readStoryModal.classList.remove('hidden');
        }

        function traceAllPathsToNode(targetNodeId) {
            const allPaths = [];
            let startNodes = nodes.filter(n => n.type === 'Scene');
            if (startNodes.length === 0) { 
                startNodes = nodes.filter(n => 
                    !wires.some(w => w.toNode === n.id && (w.toPort === 'general-input')) && 
                    ['Dialogue', 'Interact', 'Directive', 'Time', 'Weather'].includes(n.type)
                );
            }
             if (startNodes.length === 0 && nodes.length > 0 && !nodes.find(n => n.id === targetNodeId && n.type === 'Scene')) { 
                startNodes = [nodes.find(n => n.id !== targetNodeId && ['Dialogue', 'Interact', 'Directive', 'Time', 'Weather', 'Scene'].includes(n.type))].filter(Boolean);
            }

            for (const startNode of startNodes) {
                if (startNode.id === targetNodeId && startNode.type === 'Scene') continue; 
                dfsPathTrace(startNode.id, targetNodeId, [], [], allPaths, new Set());
            }
            return allPaths;
        }

        function dfsPathTrace(currentNodeId, targetNodeId, currentPathNodeIds, currentPathDecisionSummaries, allPaths, visitedInCurrentPath) {
            visitedInCurrentPath.add(currentNodeId);
            currentPathNodeIds.push(currentNodeId);

            if (currentNodeId === targetNodeId) {
                allPaths.push({ nodes: [...currentPathNodeIds], decisions: [...currentPathDecisionSummaries] });
                visitedInCurrentPath.delete(currentNodeId);
                currentPathNodeIds.pop();
                return; 
            }

            const node = findNodeById(currentNodeId);
            if (!node) { 
                visitedInCurrentPath.delete(currentNodeId);
                currentPathNodeIds.pop();
                return;
            }
            
            let nextPossibleWires = [];
            if (node.type === 'Directive') {
                node.properties.options.forEach(opt => {
                    const wire = wires.find(w => w.fromNode === currentNodeId && w.fromPort === `option-${opt.id}`);
                    if (wire) nextPossibleWires.push({wire: wire, decisionSummary: opt.summary});
                });
            } else { 
                const portIdToUse = (node.type === 'Scene') ? 'narrative-out' : 'general-output';
                wires.filter(w => w.fromNode === currentNodeId && w.fromPort === portIdToUse)
                     .forEach(wire => nextPossibleWires.push({wire: wire, decisionSummary: null}));
            }

            for (const {wire, decisionSummary} of nextPossibleWires) {
                if (wire && !visitedInCurrentPath.has(wire.toNode)) {
                    if (decisionSummary) currentPathDecisionSummaries.push(decisionSummary);
                    dfsPathTrace(wire.toNode, targetNodeId, currentPathNodeIds, currentPathDecisionSummaries, allPaths, visitedInCurrentPath);
                    if (decisionSummary) currentPathDecisionSummaries.pop(); 
                }
            }
            
            visitedInCurrentPath.delete(currentNodeId);
            currentPathNodeIds.pop();
        }


        // --- Initial Setup ---
        initializeLeftPanel();
        checkSavedGraph(); 
        
        const savedGraphData = getCookie('storyGraphData_slices') ? null : getCookie('storyGraphData_0'); 
        if (getCookie('storyGraphData_slices') || savedGraphData) { 
            try {
                let graphDataToLoad;
                const numSlicesStr = getCookie('storyGraphData_slices');
                if (numSlicesStr) {
                    let fullEncoded = "";
                    const numSlices = parseInt(numSlicesStr, 10);
                    for(let i=0; i<numSlices; i++) {
                        fullEncoded += getCookie(`storyGraphData_${i}`) || "";
                    }
                    if (fullEncoded) graphDataToLoad = JSON.parse(decodeURIComponent(fullEncoded));
                } else if (savedGraphData) { 
                     graphDataToLoad = JSON.parse(decodeURIComponent(savedGraphData));
                } else { 
                    const veryOldCookie = getCookie('storyGraphData');
                    if (veryOldCookie) graphDataToLoad = JSON.parse(decodeURIComponent(veryOldCookie));
                }


                if (graphDataToLoad) {
                    if (graphDataToLoad.darkMode) {
                        document.body.classList.add('dark');
                        darkModeToggle.checked = true;
                    }
                    highestZIndex = graphDataToLoad.highestZIndex || 1;
                    storyTitle = graphDataToLoad.storyTitle || "My Awesome Story";
                    storyAuthor = graphDataToLoad.storyAuthor || "";
                    storyTags = graphDataToLoad.storyTags || "";
                    alwaysDownloadOnSave = graphDataToLoad.alwaysDownloadOnSave || false;
                }
            } catch (e) { console.error("Error parsing initial data from cookie", e); }
        }
        storyTitleInput.value = storyTitle;
        storyAuthorInput.value = storyAuthor;
        storyTagsInput.value = storyTags;
        alwaysDownloadToggle.checked = alwaysDownloadOnSave;


        const dot = darkModeToggle.parentElement.querySelector('.dot');
        if (darkModeToggle.checked) { dot.style.transform = 'translateX(100%)'; } 
        else { dot.style.transform = 'translateX(0%)'; }
        
        const alwaysDownloadDot = alwaysDownloadToggle.closest('label').querySelector('.dot'); 
        if (alwaysDownloadToggle.checked) { alwaysDownloadDot.style.transform = 'translateX(100%)'; }
        else { alwaysDownloadDot.style.transform = 'translateX(0%)'; }


        graphCanvas.style.cursor = 'grab';
        updateWorldTransform(); 

        if ((getCookie('storyGraphData_slices') || getCookie('storyGraphData_0') || getCookie('storyGraphData')) && startupModal.classList.contains('hidden')) { 
            loadGraphFromCookies();
        }


    </script>
</body>
</html>
